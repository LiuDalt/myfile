<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0055)http://blog.csdn.net/cffishappy/article/details/7352898 -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  

    <script type="text/javascript" async="" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/ccom"></script><script src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/hm.js.下载"></script><script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/tracking.js.下载" charset="utf-8"></script>  

    <script type="text/javascript">
        var protocol = window.location.protocol;
        document.write('<script type="text/javascript" src="' + protocol + '//csdnimg.cn/pubfooter/js/repoAddr2.js?v=' + Math.random() + '"></' + 'script>');
    </script><script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/repoAddr2.js.下载"></script>

  
 <meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" media="handheld" href="http://blog.csdn.net/cffishappy/article/details/7352898#">

    <title>ffmpeg教程 - cffishappy的专栏
        - 博客频道 - CSDN.NET</title>
    
    <meta name="description" content="近期看了一些JVM和并发编程的知识,来做一个关于(线程池线程数与(CPU密集型任务和I/O密集型任务)的关系)的总结:1.任务类型举例:1.1: CPU密集型:例如,一般我们系统的静态资源,比如js,css等,会存在一个版本号,如 main.js?v0,每当用户访问这个资源的时候,会发送一个比对请求到服务端,比对本地静态文件版本和服务端的文件版本是否一致,不一致则更新.这种任务一般不占">
    <script src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/jquery.js.下载" type="text/javascript"></script>
      <script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/jquery-version.js.下载"></script>
    <script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/ad.js.下载"></script>
        <!--new top-->
       
        <link rel="stylesheet" href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/index.css">
        <!--new top-->
    
      <!-- ad begin -->
         <script language="javascript" type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/tracking.js(1).下载"></script>
    <!-- ad end-->

    <link rel="Stylesheet" type="text/css" href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/style.css">
    <link id="RSSLink" title="RSS" type="application/rss+xml" rel="alternate" href="http://blog.csdn.net/cffishappy/rss/list">
    <link rel="shortcut icon" href="http://c.csdnimg.cn/public/favicon.ico">
    <link type="text/css" rel="stylesheet" href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/default.css">
 


<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?6bcd52f51e9b3dce32bec4a3997715ac";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Hover_Arrow {position: absolute; width: 15px; height: 11px; cursor: pointer}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; color: #666666}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_Menu_Close {position: absolute; width: 31px; height: 31px; top: -15px; left: -15px}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><script src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/share.js.下载"></script><link rel="stylesheet" type="text/css" href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/job_reco.css"><link href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/bdsstyle.css" rel="stylesheet" type="text/css"><link rel="stylesheet" type="text/css" href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/style(1).css"><link rel="stylesheet" type="text/css" href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/style(2).css"><script src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/get_ads.php" type="text/javascript"></script><script src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/logger.js.下载"></script><link rel="stylesheet" href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/share_style0_16.css"></head>
<body><div id="BAIDU_DUP_fp_wrapper" style="position: absolute; left: -1px; bottom: -1px; z-index: 0; width: 0px; height: 0px; overflow: hidden; visibility: hidden; display: none;"><iframe id="BAIDU_DUP_fp_iframe" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/o.html" style="width: 0px; height: 0px; visibility: hidden; display: none;"></iframe></div><iframe frameborder="0" style="display: none;" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/saved_resource.html"></iframe><div id="MathJax_Message" style="display: none;"></div>


    <!-- 广告位开始 -->
        <ins data-revive-zoneid="149" data-revive-id="8c38e720de1c90a6f6ff52f3f89c4d57" id="revive-0-0"></ins>
    <!-- 广告位结束 -->

    
   
      <!--new top-->
    <script id="toolbar-tpl-scriptId" fixed="true" prod="blog" skin="black" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/html.js.下载" type="text/javascript"></script><div class="csdn-toolbar csdn-toolbar-skin-black ">        <div class="container row center-block ">          <div class="col-md-3 pull-left logo clearfix"><a href="http://www.csdn.net/?ref=toolbar" title="CSDN首页" target="_blank" class="icon"></a><a title="频道首页" href="http://blog.csdn.net/?ref=toolbar_logo" class="img blog-icon"></a></div>          <div class="pull-right login-wrap ">            <ul class="btns">              <li class="loginlink"><a href="https://passport.csdn.net/account/login?ref=toolbar" target="_top">登录&nbsp;</a>|<a target="_top" href="http://passport.csdn.net/account/mobileregister?ref=toolbar&amp;action=mobileRegister">&nbsp;注册</a></li>              <li class="search">                <div class="icon on-search-icon">                  <div class="wrap">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <form action="http://so.csdn.net/search" method="get" target="_blank">                      <input type="hidden" value="toolbar" name="ref" accesskey="2">                      <div class="border">                        <input placeholder="搜索" type="text" value="" name="q" accesskey="2"><span class="icon-enter-sm"></span>                      </div>                    </form>                  </div>                </div>              </li>              <li class="favor">                <div class="icon on-favor-icon">                  <div class="wrap">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <div style="display:none;" class="favor-success"><span class="msg">收藏成功</span>                      <div class="btns"><span class="btn btn-primary ok">确定</span></div>                    </div>                    <div style="display:none;" class="favor-failed"><span class="icon-danger-lg"></span><span class="msg">收藏失败，请重新收藏</span>                      <div class="btns"><span class="btn btn-primary ok">确定</span></div>                    </div>                    <form role="form" class="form-horizontal favor-form">                      <div class="form-group">                        <div class="clearfix">                          <label for="input-title" class="col-sm-2 control-label">标题</label>                          <div class="col-sm-10">                            <input id="inputTitle" type="text" placeholder="" class="title form-control">                          </div>                        </div>                        <div class="alert alert-danger"><strong></strong>标题不能为空</div>                      </div>                      <div class="form-group">                        <label for="input-url" class="col-sm-2 control-label">网址</label>                        <div class="col-sm-10">                          <input id="input-url" type="text" placeholder="" class="url form-control">                        </div>                      </div>                      <div class="form-group">                        <label for="input-tag" class="col-sm-2 tag control-label">标签</label>                        <div class="col-sm-10">                          <input id="input-tag" type="text" class="form-control tag">                        </div>                      </div>                      <div class="form-group">                        <label for="input-description" class="description col-sm-2 control-label">摘要</label>                        <div class="col-sm-10">                          <textarea id="input-description" class="form-control description"></textarea>                        </div>                      </div>                      <div class="form-group">                        <div class="col-sm-offset-2 col-sm-10 ft">                          <div class="col-sm-4 pull-left">                            <div class="checkbox">                              <label>                                <input type="checkbox" name="share" checked="checked" class="share">公开                              </label>                            </div>                          </div>                          <div class="col-sm-8 pull-right favor-btns">                            <button type="button" class="cancel btn btn-default">取消</button>                            <button type="submit" class="submit btn btn-primary">收藏</button>                          </div>                        </div>                      </div>                    </form>                  </div>                </div>              </li>              <li class="notify">                <div style="display:none" class="number"></div>                <div style="" class="icon-hasnotes-sm"></div>                <div id="header_notice_num"><div class="icon-hasnotes" style=""></div></div>                <div class="icon on-notify-icon">                  <div class="wrap">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <div id="note1" class="csdn_note" style="left: -212px; top: 425px; display: none;">                      <div class="box"><div class="notifications notice_list_con curr">  <div class="menu_title">    <span class="title"><a href="http://msg.csdn.net/letters" target="_blank" class="read_all">查看所有私信</a><a href="http://msg.csdn.net/" target="_blank" class="go_all">查看所有通知</a></span>  </div>  <div class="loading"></div>  <div class="empty">暂没有新通知</div>  <div class="notice_content" style="overflow-y: auto; max-height: 270px;"></div></div><div class="notifications detail_con" style="display: none">  <div class="menu_title">    <span class="title">      <a class="go_back" href="javascript:void 0;">返回通知列表</a>      <a class="notifications_page_none nextnote" href="javascript:void 0;">下一条</a>      <a class="notifications_page prvnote" href="javascript:void 0;">上一条</a>    </span>  </div>  <div class="notice_content" style="overflow-y: scroll; height: 250px;"></div></div><div class="error"></div></div>                    <iframe src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/saved_resource(1).html" frameborder="0" allowtransparency="true" style="z-index:-1;position:absolute;top:0;left:0;width:100%;height:100%;background:transparent"></iframe></div>                  </div>                </div>              </li>              <li class="ugc">                <div class="icon on-ugc-icon">                  <div class="wrap clearfix">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <dl>                      <dt><a href="http://geek.csdn.net/news/expert?ref=toolbar" target="_blank" class="p-news clearfix" style="display:none;"><em class="icon"></em><span>分享资讯</span></a></dt>                      <dt style="border: none;"><a href="http://u.download.csdn.net/upload?ref=toolbar" target="_blank" class="p-doc clearfix"><em class="icon"></em><span>传PPT/文档</span></a></dt>                      <dt><a href="http://bbs.csdn.net/topics/new?ref=toolbar" target="_blank" class="p-ask clearfix"><em class="icon"></em><span>提问题</span></a></dt>                      <dt><a href="http://write.blog.csdn.net/postedit?ref=toolbar" target="_blank" class="p-blog clearfix"><em class="icon"></em><span>写博客</span></a></dt>                      <dt><a href="http://u.download.csdn.net/upload?ref=toolbar" target="_blank" class="p-src clearfix"><em class="icon"></em><span>传资源</span></a></dt>                      <dt><a href="https://code.csdn.net/projects/new?ref=toolbar" target="_blank" class="c-obj clearfix"><em class="icon"></em><span>创建项目</span></a></dt>                      <dt><a href="https://code.csdn.net/snippets/new?ref=toolbar" target="_blank" class="c-code clearfix"><em class="icon"></em><span>创建代码片</span></a></dt>                    </dl>                  </div>                </div>              </li>              <li class="profile">                <div class="icon on-profile-icon"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/2_qq_21102585.jpg" class="curr-icon-img">                  <div class="wrap clearfix">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                    <div class="bd">                      <dl class="clearfix">                        <dt class="pull-left img"><a target="_blank" href="http://my.csdn.net/?ref=toolbar" class="avatar"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/2_qq_21102585.jpg"></a></dt>                        <dd class="info" style="border: none;"><a target="_blank" href="http://my.csdn.net/?ref=toolbar" class="nickname">qq_21102585</a><span class="dec"><a class="fill-dec" href="http://my.csdn.net/" target="_blank">编辑自我介绍，让更多人了解你<span class="write-icon"></span></a></span></dd>                      </dl>                    </div>                    <div class="ft clearfix"><a target="_blank" href="http://my.csdn.net/my/account/changepwd?ref=toolbar" class="pull-left"><span class="icon-cog"></span>帐号设置</a><a href="https://passport.csdn.net/account/logout?ref=toolbar" target="_top" class="pull-left" style="margin-left:132px; width:18px; height:27px; white-space:nowrap; overflow:hidden;"><span class="icon-signout"></span><span class="out">退出</span></a></div>                  </div>                </div>              </li>              <li class="apps">                <div id="chasnew123" class="hasnew" style="display: none;"></div>                <div id="cappsarea123" class="icon on-apps-icon">                  <div class="wrap clearfix">                    <div class="curr-icon-wrap">                      <div class="curr-icon"></div>                    </div>                  <div class="detail">                    <dl>                      <dt>                        <h5>社区</h5>                      </dt>                      <dd> <a href="http://blog.csdn.net/?ref=toolbar" target="_blank">博客</a></dd>                      <dd> <a href="http://bbs.csdn.net/?ref=toolbar" target="_blank">论坛</a></dd>                      <dd> <a href="http://download.csdn.net/?ref=toolbar" target="_blank">下载</a></dd>                      <dd> <a href="http://lib.csdn.net/?ref=toolbar" target="_blank">知识库</a></dd>                      <dd><a href="http://ask.csdn.net/?ref=toolbar" target="_blank">技术问答</a></dd>                      <dd><a href="http://geek.csdn.net/?ref=toolbar" target="_blank">极客头条</a></dd>                      <dd style="display:none"> <a href="http://hero.csdn.net/?ref=toolbar" target="_blank">英雄会</a></dd>                    </dl>                  </div>                  <div class="detail">                    <dl>                      <dt>                        <h5>服务</h5>                      </dt>                      <dd style="display:none"> <a href="http://job.csdn.net/?ref=toolbar" target="_blank">JOB<img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/new.gif" style="display: none; margin-top: -26px; width: 23px;"></a></dd>                      <dd> <a href="http://edu.csdn.net/?ref=toolbar" target="_blank">学院<img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/new.gif" style="display: none; margin-top: -26px; width: 23px;"></a></dd>                      <dd> <a href="https://code.csdn.net/?ref=toolbar" target="_blank">CODE</a></dd>                      <dd> <a href="http://huiyi.csdn.net/?ref=toolbar" target="_blank">活动</a></dd>                      <dd> <a href="http://www.csto.com/?ref=toolbar" target="_blank">CSTO</a></dd>                      <dd> <a href="http://mall.csdn.net/?ref=toolbar" target="_blank">C币兑换<img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/new.gif" style="display: none; margin-top: -26px; width: 23px;"></a></dd>                    </dl>                  </div>                  <div class="detail last">                    <dl>                      <dt>                        <h5>俱乐部</h5>                      </dt>                      <dd> <a href="http://cto.csdn.net/?ref=toolbar" target="_blank">CTO俱乐部</a></dd>                      <dd> <a href="http://student.csdn.net/?ref=toolbar" target="_blank">高校俱乐部</a></dd>                    </dl>                  </div>                </div>              </div>            </li>            </ul>          </div>        </div>    </div>
     <!--new top-->
    <div id="container">
        <div id="header">
    <div class="header">
        <div id="blog_title">
            <h2>
                <a href="http://blog.csdn.net/cffishappy">cffishappy的专栏</a></h2>
            <h3></h3>
            <div class="clear">
            </div>
        </div>
        <div class="clear">
        </div>
        
     
    </div>
</div>
<div id="navigator">
    <div class="navigator_bg">
    </div>
    <div class="navigator">
        <ul>           
                <li id="btnContents"><a href="http://blog.csdn.net/cffishappy?viewmode=contents"><span onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_mulu&#39;])">
                    <img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/ico_list.gif">目录视图</span></a></li>
                <li id="btnView"><a href="http://blog.csdn.net/cffishappy?viewmode=list"><span onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_zhaiyao&#39;])">
                    <img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/ico_summary.gif">摘要视图</span></a></li>
                <li id="btnRss"><a href="http://blog.csdn.net/cffishappy/rss/list"><span onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_RSS&#39;])">
                    <img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/ico_rss.gif">订阅</span></a></li>                
            

            </ul>
    </div>
</div>
<script type="text/javascript">
    var username = "cffishappy";
    var _blogger = username;
    var blog_address = "http://blog.csdn.net/cffishappy";
    var static_host = "http://static.blog.csdn.net";
    var currentUserName = "qq_21102585";  
</script>

        <div id="body">
            <div id="main">
                <div class="main">
                        <div class="ad_class">
<div class="notice tracking-ad" data-mod="popu_3"> 


<a href="http://bss.csdn.net/m/topic/edu_exam" target="_blank">
<font color="blue">2017直通软考，拿证无忧


</font></a>

&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://edu.csdn.net/huiyiCourse/detail/274" target="_blank">
<font color="red">程序员简历优化指南！ 
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://blog.csdn.net/PK.html" target="_blank">
<font color="blue">【观点】移动原生App开发 PK HTML 5开发
</font></a>

&nbsp;&nbsp;&nbsp;

<a href="http://bss.csdn.net/m/product/aliyun_essay/index" target="_blank">
<font color="red">云端应用征文大赛，秀绝招，赢无人机！
</font></a>


</div>                        </div>
                        



  
<link href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/comment1.css" type="text/css" rel="stylesheet">
<link href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/style1.css" type="text/css" rel="stylesheet">
<script language="JavaScript" type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/jquery.cookie.js.下载"></script>
<script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/main.js.下载"></script>
<link rel="stylesheet" href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/markdown_views.css">
<link rel="stylesheet" href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/category.css">
<script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/MathJax.js.下载"></script>
<script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/web-storage-cache.min.js.下载"></script>
<script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/replace.min.js.下载"></script>




  <script type="text/ecmascript">
      window.quickReplyflag = true;
           
            var isBole = false;
            
      
      var fasrc="http://my.csdn.net/my/favorite/miniadd?t=ffmpeg%e6%95%99%e7%a8%8b&u=http://blog.csdn.net/cffishappy/article/details/7352898"

    </script>
<div id="article_details" class="details">
    <div class="article_title">   
         <span class="ico ico_type_Repost"></span>


    <h1>
        <span class="link_title"><a href="http://blog.csdn.net/cffishappy/article/details/7352898">
        ffmpeg教程            
        </a></span>
    </h1>
</div>

   

        <div class="article_manage clearfix">
        <div class="article_l">
            <span class="link_categories">
            标签：
              <a href="http://www.csdn.net/tag/audio" target="_blank" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_tag&#39;]);">audio</a><a href="http://www.csdn.net/tag/video" target="_blank" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_tag&#39;]);">video</a><a href="http://www.csdn.net/tag/delay" target="_blank" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_tag&#39;]);">delay</a><a href="http://www.csdn.net/tag/stream" target="_blank" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_tag&#39;]);">stream</a><a href="http://www.csdn.net/tag/buffer" target="_blank" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_tag&#39;]);">buffer</a><a href="http://www.csdn.net/tag/codec" target="_blank" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_tag&#39;]);">codec</a>
            </span>
        </div>
        <div class="article_r">
            <span class="link_postdate">2012-03-14 14:36</span>
            <span class="link_view" title="阅读次数">58454人阅读</span>
            <span class="link_comments" title="评论次数"> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#comments" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_pinglun&#39;])">评论</a>(9)</span>
            <span class="link_collect tracking-ad" data-mod="popu_171"> <a href="javascript:void(0);" onclick="javascript:collectArticle(&#39;ffmpeg%e6%95%99%e7%a8%8b&#39;,&#39;7352898&#39;);return false;" title="收藏" target="_blank">收藏</a></span>
             <span class="link_report"> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#report" onclick="javascript:report(7352898,2);return false;" title="举报">举报</a></span>

        </div>
    </div>
    <div class="embody" style="display:none" id="embody">
        <span class="embody_t">本文章已收录于：</span>
        <div class="embody_c" id="lib" value="{&quot;err&quot;:0,&quot;msg&quot;:&quot;ok&quot;,&quot;data&quot;:[]}"></div>
    </div>
    <style type="text/css">        
            .embody{
                padding:10px 10px 10px;
                margin:0 -20px;
                border-bottom:solid 1px #ededed;                
            }
            .embody_b{
                margin:0 ;
                padding:10px 0;
            }
            .embody .embody_t,.embody .embody_c{
                display: inline-block;
                margin-right:10px;
            }
            .embody_t{
                font-size: 12px;
                color:#999;
            }
            .embody_c{
                font-size: 12px;
            }
            .embody_c img,.embody_c em{
                display: inline-block;
                vertical-align: middle;               
            }
             .embody_c img{               
                width:30px;
                height:30px;
            }
            .embody_c em{
                margin: 0 20px 0 10px;
                color:#333;
                font-style: normal;
            }
    </style>
    <script type="text/javascript">
        $(function () {
            try
            {
                var lib = eval("("+$("#lib").attr("value")+")");
                var html = "";
                if (lib.err == 0) {
                    $.each(lib.data, function (i) {
                        var obj = lib.data[i];
                        //html += '<img src="' + obj.logo + '"/>' + obj.name + "&nbsp;&nbsp;";
                        html += ' <a href="' + obj.url + '" target="_blank">';
                        html += ' <img src="' + obj.logo + '">';
                        html += ' <em><b>' + obj.name + '</b></em>';
                        html += ' </a>';
                    });
                    if (html != "") {
                        setTimeout(function () {
                            $("#lib").html(html);                      
                            $("#embody").show();
                        }, 100);
                    }
                }      
            } catch (err)
            { }
            
        });
    </script>
      <div class="category clearfix">
        <div class="category_l">
           <img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/category_icon.jpg">
            <span>分类：</span>
        </div>
        <div class="category_r">
                    <label onclick="GetCategoryArticles(&#39;883975&#39;,&#39;cffishappy&#39;,&#39;top&#39;,&#39;7352898&#39;);">
                        <span onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_fenlei&#39;]);">流媒体<em>（47）</em></span>
                      <img class="arrow-down" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/arrow_triangle _down.jpg" style="display:inline;">
                      <img class="arrow-up" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/arrow_triangle_up.jpg" style="display:none;">
                        <div class="subItem">
                            <div class="subItem_t"><a href="http://blog.csdn.net/cffishappy/article/category/883975" target="_blank">作者同类文章</a><i class="J_close">X</i></div>
                            <ul class="subItem_l" id="top_883975">                            
                            </ul>
                        </div>
                    </label>                    
        </div>
    </div>
    <script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/category.js.下载"></script>  

  

  
  
     

<div style="clear:both"></div><div style="border:solid 1px #ccc; background:#eee; float:left; min-width:200px;padding:4px 10px;"><p style="text-align:right;margin:0;"><span style="float:left;">目录<a href="http://blog.csdn.net/cffishappy/article/details/7352898#" title="系统根据文章中H1到H6标签自动生成文章目录">(?)</a></span><a href="http://blog.csdn.net/cffishappy/article/details/7352898#" onclick="javascript:return openct(this);" title="展开">[+]</a></p><ol style="display:none;margin-left:14px;padding-left:14px;line-height:160%;"><li><a href="http://blog.csdn.net/cffishappy/article/details/7352898#t0">ffmpeg文档2</a></li><ol><li><a href="http://blog.csdn.net/cffishappy/article/details/7352898#t1">杂谈</a></li></ol><li><a href="http://blog.csdn.net/cffishappy/article/details/7352898#t2">ffmpeg文档4</a></li><ol><li><a href="http://blog.csdn.net/cffishappy/article/details/7352898#t3">杂谈</a></li></ol><li><a href="http://blog.csdn.net/cffishappy/article/details/7352898#t4">ffmpeg文档5</a></li><ol><li><a href="http://blog.csdn.net/cffishappy/article/details/7352898#t5">杂谈</a></li></ol><li><a href="http://blog.csdn.net/cffishappy/article/details/7352898#t6">ffmpeg文档6</a></li><ol><li><a href="http://blog.csdn.net/cffishappy/article/details/7352898#t7">杂谈</a></li></ol><li><a href="http://blog.csdn.net/cffishappy/article/details/7352898#t8">ffmpeg文档7</a></li><ol><li><a href="http://blog.csdn.net/cffishappy/article/details/7352898#t9">杂谈</a></li></ol><li><a href="http://blog.csdn.net/cffishappy/article/details/7352898#t10">个人翻译ffmpeg文档8</a></li><ol><li><a href="http://blog.csdn.net/cffishappy/article/details/7352898#t11">杂谈</a></li></ol></ol></div><div style="clear:both"></div><div id="article_content" class="article_content">

<p>&nbsp;转：<a href="http://blog.sina.com.cn/s/blog_51396f890100nd91.html">http://blog.sina.com.cn/s/blog_51396f890100nd91.html</a><wbr><wbr></p>
<p><strong>概要</strong></p>
<p><strong>&nbsp;</strong>电影文件有很多基本的组成部分。首先，文件本身被称为<strong>容器<a href="http://lib.csdn.net/base/docker" class="replace_word" title="Docker知识库" target="_blank" style="color:#df3434; font-weight:bold;">Container</a></strong>，容器的类型决定了信息被存放在文件中的位置。AVI和Quicktime就是容器的例子。接着，你有一组<strong>流</strong>，例如，你经常有的是一个音频流和一个视频流。（一个流只是一种想像出来的词语，用来表示一连串的通过时间来串连的数据元素）。在流中的数据元素被称为<strong>帧Frame</strong>。每个流是由不同的编码器来编码生成的。编解码器描述了实际的数据是如何被编码Coded和解码DECoded的，因此它的名字叫做CODEC。Divx和
 MP3就是编解码器的例子。接着从流中被读出来的叫做包Packets。包是一段数据，它包含了一段可以被解码成方便我们最后在应用程序中操作的原始帧的数据。根据我们的目的，每个包包含了完整的帧或者对于音频来说是许多格式的完整帧。</p>
<p>&nbsp;<wbr><wbr></p>
<p>基本上来说，处理视频和音频流是很容易的：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>10 从video.avi文件中打开视频流video_stream</p>
<p>20 从视频流中读取包到帧中</p>
<p>30 如果这个帧还不完整，跳到20</p>
<p>40 对这个帧进行一些操作</p>
<p>50 跳回到20</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;<wbr><wbr></p>
<p>在这个程序中使用ffmpeg来处理多种媒体是相当容易的，虽然很多程序可能在对帧进行操作的时候非常的复杂。因此在这篇指导中，我们将打开一个文件，读取里面的视频流，而且我们对帧的操作将是把这个帧写到一个PPM文件中。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>打开文件</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>首先，来看一下我们如何打开一个文件。通过ffmpeg，你必需先初始化这个库。（注意在某些系统中必需用&lt;ffmpeg/avcodec.h&gt;和&lt;ffmpeg/avformat.h&gt;来替换）</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>#include &lt;avcodec.h&gt;</p>
<p>#include &lt;avformat.h&gt;</p>
<p>...</p>
<p>int main(int argc, charg *argv[]) {</p>
<p>av_register_all();</p>
</td>
</tr>
</tbody>
</table>
<p>这里注册了所有的文件格式和编解码器的库，所以它们将被自动的使用在被打开的合适格式的文件上。注意你只需要调用av_register_all()一次，因此我们在主函数main()中来调用它。如果你喜欢，也可以只注册特定的格式和编解码器，但是通常你没有必要这样做。</p>
<p>&nbsp;<wbr><wbr></p>
<p>现在我们可以真正的打开文件：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>AVFormatContext *pFormatCtx;</p>
<p>&nbsp;<wbr><wbr></p>
<p>// Open video file</p>
<p>if(av_open_input_file(&amp;pFormatCtx, argv[1], NULL, 0, NULL)!=0)</p>
<p>&nbsp;<wbr><wbr> return -1; // Couldn't open file</p>
</td>
</tr>
</tbody>
</table>
<p>我们通过第一个参数来获得文件名。这个函数读取文件的头部并且把信息保存到我们给的AVFormatContext结构体中。最后三个参数用来指定特殊的文件格式，缓冲大小和格式参数，但如果把它们设置为空NULL或者0，libavformat将自动检测这些参数。</p>
<p>&nbsp;<wbr><wbr></p>
<p>这个函数只是检测了文件的头部，所以接着我们需要检查在文件中的流的信息：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>// Retrieve stream information</p>
<p>if(av_find_stream_info(pFormatCtx)&lt;0)</p>
<p>&nbsp;<wbr><wbr> return -1; // Couldn't find stream information</p>
</td>
</tr>
</tbody>
</table>
<p>这个函数为pFormatCtx-&gt;streams填充上正确的信息。我们引进一个手工调试的函数来看一下里面有什么：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>// Dump information about file onto standard error</p>
<p>dump_format(pFormatCtx, 0, argv[1], 0);</p>
</td>
</tr>
</tbody>
</table>
<p>现在pFormatCtx-&gt;streams仅仅是一组大小为pFormatCtx-&gt;nb_streams的指针，所以让我们先跳过它直到我们找到一个视频流。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>int i;</p>
<p>AVCodecContext *pCodecCtx;</p>
<p>&nbsp;<wbr><wbr></p>
<p>// Find the first video stream</p>
<p>videoStream=-1;</p>
<p>for(i=0; i&lt;pFormatCtx-&gt;nb_streams; i++)</p>
<p>&nbsp;<wbr><wbr> if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==CODEC_TYPE_VIDEO) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> videoStream=i;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>if(videoStream==-1)</p>
<p>&nbsp;<wbr><wbr> return -1; // Didn't find a video stream</p>
<p>&nbsp;<wbr><wbr></p>
<p>// Get a pointer to the codec context for the video stream</p>
<p>pCodecCtx=pFormatCtx-&gt;streams[videoStream]-&gt;codec;</p>
</td>
</tr>
</tbody>
</table>
<p>流中关于编解码器的信息就是被我们叫做"codec context"（编解码器上下文）的东西。这里面包含了流中所使用的关于编解码器的所有信息，现在我们有了一个指向他的指针。但是我们必需要找到真正的编解码器并且打开它：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>AVCodec *pCodec;</p>
<p>&nbsp;<wbr><wbr></p>
<p>// Find the decoder for the video stream</p>
<p>pCodec=avcodec_find_decoder(pCodecCtx-&gt;codec_id);</p>
<p>if(pCodec==NULL) {</p>
<p>&nbsp;<wbr><wbr> fprintf(stderr, "Unsupported codec!\n");</p>
<p>&nbsp;<wbr><wbr> return -1; // Codec not found</p>
<p>}</p>
<p>// Open codec</p>
<p>if(avcodec_open(pCodecCtx, pCodec)&lt;0)</p>
<p>&nbsp;<wbr><wbr> return -1; // Could not open codec</p>
</td>
</tr>
</tbody>
</table>
<p>有些人可能会从旧的指导中记得有两个关于这些代码其它部分：添加CODEC_FLAG_TRUNCATED到pCodecCtx-&gt;flags和添加一个hack来粗糙的修正帧率。这两个修正已经不在存在于ffplay.c中。因此，我必需假设它们不再必要。我们移除了那些代码后还有一个需要指出的不同点：pCodecCtx-&gt;time_base现在已经保存了帧率的信息。time_base是一个结构体，它里面有一个分子和分母 (AVRational)。我们使用分数的方式来表示帧率是因为很多编解码器使用非整数的帧率（例如NTSC使用29.97fps）。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>保存数据</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>现在我们需要找到一个地方来保存帧：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>AVFrame *pFrame;</p>
<p>&nbsp;<wbr><wbr></p>
<p>// Allocate video frame</p>
<p>pFrame=avcodec_alloc_frame();</p>
</td>
</tr>
</tbody>
</table>
<p>因为我们准备输出保存24位RGB色的PPM文件，我们必需把帧的格式从原来的转换为RGB。FFMPEG将为我们做这些转换。在大多数项目中（包括我们的这个）我们都想把原始的帧转换成一个特定的格式。让我们先为转换来申请一帧的内存。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>// Allocate an AVFrame structure</p>
<p>pFrameRGB=avcodec_alloc_frame();</p>
<p>if(pFrameRGB==NULL)</p>
<p>&nbsp;<wbr><wbr> return -1;</p>
</td>
</tr>
</tbody>
</table>
<p>即使我们申请了一帧的内存，当转换的时候，我们仍然需要一个地方来放置原始的数据。我们使用avpicture_get_size来获得我们需要的大小，然后手工申请内存空间：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>uint8_t *buffer;</p>
<p>int numBytes;</p>
<p>// Determine required buffer size and allocate buffer</p>
<p>numBytes=avpicture_get_size(PIX_FMT_RGB24, pCodecCtx-&gt;width,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>
 pCodecCtx-&gt;height);</p>
<p>buffer=(uint8_t *)av_malloc(numBytes*sizeof(uint8_t));</p>
</td>
</tr>
</tbody>
</table>
<p>av_malloc是ffmpeg的malloc，用来实现一个简单的malloc的包装，这样来保证内存地址是对齐的（4字节对齐或者2字节对齐）。它并不能保护你不被内存泄漏，重复释放或者其它malloc的问题所困扰。</p>
<p>现在我们使用avpicture_fill来把帧和我们新申请的内存来结合。关于AVPicture的结成：AVPicture结构体是AVFrame结构体的子集――AVFrame结构体的开始部分与AVPicture结构体是一样的。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>// Assign appropriate parts of buffer to image planes in pFrameRGB</p>
<p>// Note that pFrameRGB is an AVFrame, but AVFrame is a superset</p>
<p>// of AVPicture</p>
<p>avpicture_fill((AVPicture *)pFrameRGB, buffer, PIX_FMT_RGB24,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pCodecCtx-&gt;width, pCodecCtx-&gt;height);</p>
</td>
</tr>
</tbody>
</table>
<p>最后，我们已经准备好来从流中读取数据了。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>读取数据</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>我们将要做的是通过读取包来读取整个视频流，然后把它解码成帧，最好后转换格式并且保存。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>int frameFinished;</p>
<p>AVPacket packet;</p>
<p>&nbsp;<wbr><wbr></p>
<p>i=0;</p>
<p>while(av_read_frame(pFormatCtx, &amp;packet)&gt;=0) {</p>
<p>&nbsp;<wbr><wbr> // Is this a packet from the video stream?</p>
<p>&nbsp;<wbr><wbr> if(packet.stream_index==videoStream) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // Decode video frame</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> avcodec_decode_video(pCodecCtx, pFrame, &amp;frameFinished,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>packet.data,
 packet.size);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // Did we get a video frame?</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(frameFinished) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // Convert the image from its native format to RGB</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> img_convert((AVPicture *)pFrameRGB, PIX_FMT_RGB24,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> (AVPicture*)pFrame, pCodecCtx-&gt;pix_fmt,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pCodecCtx-&gt;width, pCodecCtx-&gt;height);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // Save the frame to disk</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(++i&lt;=5)</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SaveFrame(pFrameRGB, pCodecCtx-&gt;width,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pCodecCtx-&gt;height, i);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> // Free the packet that was allocated by av_read_frame</p>
<p>&nbsp;<wbr><wbr> av_free_packet(&amp;packet);</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>这个循环过程是比较简单的：av_read_frame()读取一个包并且把它保存到AVPacket结构体中。注意我们仅仅申请了一个包的结构体 ――ffmpeg为我们申请了内部的数据的内存并通过packet.data指针来指向它。这些数据可以在后面通过av_free_packet()来释放。函数avcodec_decode_video()把包转换为帧。然而当解码一个包的时候，我们可能没有得到我们需要的关于帧的信息。因此，当我们得到下一帧的时候，avcodec_decode_video()为我们设置了帧结束标志frameFinished。最后，我们使用
 img_convert()函数来把帧从原始格式（pCodecCtx-&gt;pix_fmt）转换成为RGB格式。要记住，你可以把一个 AVFrame结构体的指针转换为AVPicture结构体的指针。最后，我们把帧和高度宽度信息传递给我们的SaveFrame函数。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p><strong>关于包Packets的注释</strong></p>
<p>从技术上讲一个包可以包含部分或者其它的数据，但是ffmpeg的解释器保证了我们得到的包Packets包含的要么是完整的要么是多种完整的帧。</p>
</td>
</tr>
</tbody>
</table>
<p>现在我们需要做的是让SaveFrame函数能把RGB信息定稿到一个PPM格式的文件中。我们将生成一个简单的PPM格式文件，请相信，它是可以工作的。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>void SaveFrame(AVFrame *pFrame, int width, int height, int iFrame) {</p>
<p>&nbsp;<wbr><wbr> FILE *pFile;</p>
<p>&nbsp;<wbr><wbr> char szFilename[32];</p>
<p>&nbsp;<wbr><wbr> int&nbsp;<wbr><wbr> y;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> // Open file</p>
<p>&nbsp;<wbr><wbr> sprintf(szFilename, "frame%d.ppm", iFrame);</p>
<p>&nbsp;<wbr><wbr> pFile=fopen(szFilename, "wb");</p>
<p>&nbsp;<wbr><wbr> if(pFile==NULL)</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> return;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> // Write header</p>
<p>&nbsp;<wbr><wbr> fprintf(pFile, "P6\n%d %d\n255\n", width, height);</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> // Write pixel data</p>
<p>&nbsp;<wbr><wbr> for(y=0; y&lt;height; y++)</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> fwrite(pFrame-&gt;data[0]+y*pFrame-&gt;linesize[0], 1, width*3, pFile);</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> // Close file</p>
<p>&nbsp;<wbr><wbr> fclose(pFile);</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>我们做了一些标准的文件打开动作，然后写入RGB数据。我们一次向文件写入一行数据。PPM格式文件的是一种包含一长串的RGB数据的文件。如果你了解 HTML色彩表示的方式，那么它就类似于把每个像素的颜色头对头的展开，就像#ff0000#ff0000....就表示了了个红色的屏幕。（它被保存成二进制方式并且没有分隔符，但是你自己是知道如何分隔的）。文件的头部表示了图像的宽度和高度以及最大的RGB值的大小。</p>
<p>现在，回顾我们的main()函数。一旦我们开始读取完视频流，我们必需清理一切：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>// Free the RGB image</p>
<p>av_free(buffer);</p>
<p>av_free(pFrameRGB);</p>
<p>&nbsp;<wbr><wbr></p>
<p>// Free the YUV frame</p>
<p>av_free(pFrame);</p>
<p>&nbsp;<wbr><wbr></p>
<p>// Close the codec</p>
<p>avcodec_close(pCodecCtx);</p>
<p>&nbsp;<wbr><wbr></p>
<p>// Close the video file</p>
<p>av_close_input_file(pFormatCtx);</p>
<p>&nbsp;<wbr><wbr></p>
<p>return 0;</p>
</td>
</tr>
</tbody>
</table>
<p>你会注意到我们使用av_free来释放我们使用avcode_alloc_fram和av_malloc来分配的内存。</p>
<p>上面的就是代码！下面，我们将使用<a href="http://lib.csdn.net/base/linux" class="replace_word" title="Linux知识库" target="_blank" style="color:#df3434; font-weight:bold;">Linux</a>或者其它类似的平台，你将运行：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>gcc -o tutorial01 tutorial01.c -lavutil -lavformat -lavcodec -lz -lavutil -lm</p>
</td>
</tr>
</tbody>
</table>
<p>如果你使用的是老版本的ffmpeg，你可以去掉-lavutil参数：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>gcc -o tutorial01 tutorial01.c -lavutil -lavformat -lavcodec -lz -lm</p>
</td>
</tr>
</tbody>
</table>
<p>大多数的图像处理函数可以打开PPM文件。可以使用一些电影文件来进行<a href="http://lib.csdn.net/base/softwaretest" class="replace_word" title="软件测试知识库" target="_blank" style="color:#df3434; font-weight:bold;">测试</a>。</p>
<h2><a name="t0"></a>ffmpeg文档2</h2>
<span>(2008-08-26 09:41:29)</span>
<div><a><cite><img title="ffmpeg文档12345678" height="15" alt="ffmpeg文档12345678" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/sg_trans.gif" width="15" align="absMiddle">转载</cite></a></div>
<div>
<table>
<tbody>
<tr>
<td><span>标签：</span>
<h3><a name="t1"></a><a href="http://uni.sina.com.cn/c.php?t=blog&amp;k=%EF%BF%BD%EF%BF%BD%CC%B8&amp;ts=bpost&amp;stype=tag" target="_blank">杂谈</a></h3>
</td>
<td><span>分类：</span> <a href="http://blog.sina.com.cn/s/articlelist_1188849065_1_1.html" target="_blank">
翻译文档</a></td>
</tr>
</tbody>
</table>
</div>
<div>
<p align="center"><strong>指导2：输出到屏幕</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>SDL和视频</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>为了在屏幕上显示，我们将使用SDL.SDL是Simple Direct Layer的缩写。它是一个出色的多媒体库，适用于多平台，并且被用在许多工程中。你可以从它的官方网站的网址 http://www.libsdl.org/上来得到这个库的源代码或者如果有可能的话你可以直接下载开发包到你的<a href="http://lib.csdn.net/base/operatingsystem" class="replace_word" title="操作系统知识库" target="_blank" style="color:#df3434; font-weight:bold;">操作系统</a>中。按照这个指导，你将需要编译这个库。（剩下的几个指导中也是一样）</p>
<p>SDL库中有许多种方式来在屏幕上绘制图形，而且它有一个特殊的方式来在屏幕上显示图像――这种方式叫做YUV覆盖。YUV（从技术上来讲并不叫YUV而是叫做YCbCr）是一种类似于RGB方式的存储原始图像的格式。粗略的讲，Y是亮度分量，U和V是色度分量。（这种格式比RGB复杂的多，因为很多的颜色信息被丢弃了，而且你可以每2个Y有1个U和1个V）。SDL的YUV覆盖使用一组原始的YUV数据并且在屏幕上显示出他们。它可以允许4种不同的 YUV格式，但是其中的YV12是最快的一种。还有一个叫做YUV420P的YUV格式，它和YV12是一样的，除了U和V分量的位置被调换了以外。
 420意味着它以4：2：0的比例进行了二次抽样，基本上就意味着1个颜色分量对应着4个亮度分量。所以它的色度信息只有原来的1/4。这是一种节省带宽的好方式，因为人眼感觉不到这种变化。在名称中的P表示这种格式是平面的――简单的说就是Y，U和V分量分别在不同的数组中。FFMPEG可以把图像格式转换为YUV420P，但是现在很多视频流的格式已经是YUV420P的了或者可以被很容易的转换成YUV420P格式。</p>
<p>于是，我们现在计划把指导1中的SaveFrame()函数替换掉，让它直接输出我们的帧到屏幕上去。但一开始我们必需要先看一下如何使用SDL库。首先我们必需先包含SDL库的头文件并且初始化它。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>#include &lt;SDL.h&gt;</p>
<p>#include &lt;SDL_thread.h&gt;</p>
<p>&nbsp;<wbr><wbr></p>
<p>if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {</p>
<p>&nbsp;<wbr><wbr> fprintf(stderr, "Could not initialize SDL - %s\n", SDL_GetError());</p>
<p>&nbsp;<wbr><wbr> exit(1);</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>SDL_Init()函数告诉了SDL库，哪些特性我们将要用到。当然SDL_GetError()是一个用来手工除错的函数。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>创建一个显示</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>现在我们需要在屏幕上的一个地方放上一些东西。在SDL中显示图像的基本区域叫做<strong>面surface</strong>。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>SDL_Surface *screen;</p>
<p>&nbsp;<wbr><wbr></p>
<p>screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, 0, 0);</p>
<p>if(!screen) {</p>
<p>&nbsp;<wbr><wbr> fprintf(stderr, "SDL: could not set video mode - exiting\n");</p>
<p>&nbsp;<wbr><wbr> exit(1);</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>这就创建了一个给定高度和宽度的屏幕。下一个选项是屏幕的颜色深度――0表示使用和当前一样的深度。（这个在OS X系统上不能正常工作，原因请看源代码）</p>
<p>现在我们在屏幕上来创建一个YUV覆盖以便于我们输入视频上去：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>SDL_Overlay&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> *bmp;</p>
<p>&nbsp;<wbr><wbr></p>
<p>bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width, pCodecCtx-&gt;height,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>
 SDL_YV12_OVERLAY, screen);</p>
</td>
</tr>
</tbody>
</table>
<p>正如前面我们所说的，我们使用YV12来显示图像。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>显示图像</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>前面那些都是很简单的。现在我们需要来显示图像。让我们看一下是如何来处理完成后的帧的。我们将原来对RGB处理的方式，并且替换SaveFrame() 为显示到屏幕上的代码。为了显示到屏幕上，我们将先建立一个AVPicture结构体并且设置其数据指针和行尺寸来为我们的YUV覆盖服务：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr> if(frameFinished) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_LockYUVOverlay(bmp);</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> AVPicture pict;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.data[0] = bmp-&gt;pixels[0];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.data[1] = bmp-&gt;pixels[2];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.data[2] = bmp-&gt;pixels[1];</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.linesize[0] = bmp-&gt;pitches[0];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.linesize[1] = bmp-&gt;pitches[2];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.linesize[2] = bmp-&gt;pitches[1];</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // Convert the image into YUV format that SDL uses</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> img_convert(&amp;pict, PIX_FMT_YUV420P,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> (AVPicture *)pFrame, pCodecCtx-&gt;pix_fmt,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pCodecCtx-&gt;width, pCodecCtx-&gt;height);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_UnlockYUVOverlay(bmp);</p>
<p>&nbsp;<wbr><wbr> }&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
</td>
</tr>
</tbody>
</table>
<p>首先，我们锁定这个覆盖，因为我们将要去改写它。这是一个避免以后发生问题的好习惯。正如前面所示的，这个AVPicture结构体有一个数据指针指向一个有4个元素的指针数据。由于我们处理的是YUV420P，所以我们只需要3个通道即只要三组数据。其它的格式可能需要第四个指针来表示alpha通道或者其它参数。行尺寸正如它的名字表示的意义一样。在YUV覆盖中相同功能的结构体是像素pixel和程度pitch。（程度pitch是在SDL里用来表示指定行数据宽度的值）。所以我们现在做的是让我们的覆盖中的pict.data中的三个指针有一个指向必要的空间的地址。类似的，我们可以直接从覆盖中得到行尺寸信息。像前面一样我们使用img_convert来把格式转换成PIX_FMT_YUV420P。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>绘制图像</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>但我们仍然需要告诉SDL如何来实际显示我们给的数据。我们也会传递一个表明电影位置、宽度、高度和缩放大小的矩形参数给SDL的函数。这样，SDL为我们做缩放并且它可以通过显卡的帮忙来进行快速缩放。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>SDL_Rect rect;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> if(frameFinished) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // Convert the image into YUV format that SDL uses</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> img_convert(&amp;pict, PIX_FMT_YUV420P,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> (AVPicture *)pFrame, pCodecCtx-&gt;pix_fmt,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pCodecCtx-&gt;width, pCodecCtx-&gt;height);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_UnlockYUVOverlay(bmp);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> rect.x = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> rect.y = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> rect.w = pCodecCtx-&gt;width;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> rect.h = pCodecCtx-&gt;height;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_DisplayYUVOverlay(bmp, &amp;rect);</p>
<p>&nbsp;<wbr><wbr> }</p>
</td>
</tr>
</tbody>
</table>
<p>现在我们的视频显示出来了！</p>
<p>&nbsp;<wbr><wbr></p>
<p>让我们再花一点时间来看一下SDL的特性：它的事件驱动系统。SDL被设置成当你在SDL中点击或者移动鼠标或者向它发送一个信号它都将产生一个事件的驱动方式。如果你的程序想要处理用户输入的话，它就会检测这些事件。你的程序也可以产生事件并且传递给SDL事件系统。当使用SDL进行多线程编程的时候，这相当有用，这方面代码我们可以在指导4中看到。在这个程序中，我们将在处理完包以后就立即轮询事件。现在而言，我们将处理SDL_QUIT事件以便于我们退出：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>SDL_Event&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> event;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> av_free_packet(&amp;packet);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_PollEvent(&amp;event);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> switch(event.type) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> case SDL_QUIT:</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_Quit();</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> exit(0);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> default:</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
</td>
</tr>
</tbody>
</table>
<p>让我们去掉旧的冗余代码，开始编译。如果你使用的是Linux或者其变体，使用SDL库进行编译的最好方式为：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>gcc -o tutorial02 tutorial02.c -lavutil -lavformat -lavcodec -lz -lm \</p>
<p>`sdl-config --cflags --libs`</p>
</td>
</tr>
</tbody>
</table>
<p>这里的sdl-config命令会打印出用于gcc编译的包含正确SDL库的适当参数。为了进行编译，在你自己的平台你可能需要做的有点不同：请查阅一下SDL文档中关于你的系统的那部分。一旦可以编译，就马上运行它。</p>
<p>&nbsp;<wbr><wbr></p>
<p>当运行这个程序的时候会发生什么呢？电影简直跑疯了！实际上，我们只是以我们能从文件中解码帧的最快速度显示了所有的电影的帧。现在我们没有任何代码来计算出我们什么时候需要显示电影的帧。最后（在指导5），我们将花足够的时间来探讨同步问题。但一开始我们会先忽略这个，因为我们有更加重要的事情要处理：音频！</p>
</div>
<p><br>
</p>
<p><br>
</p>
<div>
<p align="center"><strong>指导3：播放声音</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>现在我们要来播放声音。SDL也为我们准备了输出声音的方法。函数SDL_OpenAudio()本身就是用来打开声音设备的。它使用一个叫做SDL_AudioSpec结构体作为参数，这个结构体中包含了我们将要输出的音频的所有信息。</p>
<p>在我们展示如何建立之前，让我们先解释一下电脑是如何处理音频的。数字音频是由一长串的样本流组成的。每个样本表示声音波形中的一个值。声音按照一个特定的采样率来进行录制，采样率表示以多快的速度来播放这段样本流，它的表示方式为每秒多少次采样。例如22050和44100的采样率就是电台和CD常用的采样率。此外，大多音频有不只一个通道来表示立体声或者环绕。例如，如果采样是立体声，那么每次的采样数就为2个。当我们从一个电影文件中等到数据的时候，我们不知道我们将得到多少个样本，但是ffmpeg将不会给我们部分的样本――这意味着它将不会把立体声分割开来。</p>
<p>SDL播放声音的方式是这样的：你先设置声音的选项：采样率（在SDL的结构体中被叫做freq的表示频率frequency），声音通道数和其它的参数，然后我们设置一个回调函数和一些用户数据userdata。当开始播放音频的时候，SDL将不断地调用这个回调函数并且要求它来向声音缓冲填入一个特定的数量的字节。当我们把这些信息放到SDL_AudioSpec结构体中后，我们调用函数SDL_OpenAudio()就会打开声音设备并且给我们送回另外一个AudioSpec结构体。这个结构体是我们实际上用到的－－因为我们不能保证得到我们所要求的。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>设置音频</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>目前先把讲的记住，因为我们实际上还没有任何关于声音流的信息。让我们回过头来看一下我们的代码，看我们是如何找到视频流的，同样我们也可以找到声音流。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>// Find the first video stream</p>
<p>videoStream=-1;</p>
<p>audioStream=-1;</p>
<p>for(i=0; i &lt; pFormatCtx-&gt;nb_streams; i++) {</p>
<p>&nbsp;<wbr><wbr> if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==CODEC_TYPE_VIDEO</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &amp;&amp;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> videoStream &lt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> videoStream=i;</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==CODEC_TYPE_AUDIO &amp;&amp;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> audioStream &lt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> audioStream=i;</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>}</p>
<p>if(videoStream==-1)</p>
<p>&nbsp;<wbr><wbr> return -1; // Didn't find a video stream</p>
<p>if(audioStream==-1)</p>
<p>&nbsp;<wbr><wbr> return -1;</p>
</td>
</tr>
</tbody>
</table>
<p>从这里我们可以从描述流的AVCodecContext中得到我们想要的信息，就像我们得到视频流的信息一样。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>AVCodecContext *aCodecCtx;</p>
<p>&nbsp;<wbr><wbr></p>
<p>aCodecCtx=pFormatCtx-&gt;streams[audioStream]-&gt;codec;</p>
</td>
</tr>
</tbody>
</table>
<p>包含在编解码上下文中的所有信息正是我们所需要的用来建立音频的信息：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>wanted_spec.freq = aCodecCtx-&gt;sample_rate;</p>
<p>wanted_spec.format = AUDIO_S16SYS;</p>
<p>wanted_spec.channels = aCodecCtx-&gt;channels;</p>
<p>wanted_spec.silence = 0;</p>
<p>wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;</p>
<p>wanted_spec.callback = audio_callback;</p>
<p>wanted_spec.userdata = aCodecCtx;</p>
<p>&nbsp;<wbr><wbr></p>
<p>if(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; 0) {</p>
<p>&nbsp;<wbr><wbr> fprintf(stderr, "SDL_OpenAudio: %s\n", SDL_GetError());</p>
<p>&nbsp;<wbr><wbr> return -1;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>让我们浏览一下这些：</p>
<p>&nbsp;<wbr><wbr> ·freq 前面所讲的采样率</p>
<p>&nbsp;<wbr><wbr> ·format 告诉SDL我们将要给的格式。在“S16SYS”中的S表示有符号的signed，16表示每个样本是16位长的，SYS表示大小头的顺序是与使用的系统相同的。这些格式是由avcodec_decode_audio2为我们给出来的输入音频的格式。</p>
<p>&nbsp;<wbr><wbr> ·channels 声音的通道数</p>
<p>&nbsp;<wbr><wbr> ·silence 这是用来表示静音的值。因为声音采样是有符号的，所以0当然就是这个值。</p>
<p>&nbsp;<wbr><wbr> ·samples 这是当我们想要更多声音的时候，我们想让SDL给出来的声音缓冲区的尺寸。一个比较合适的值在512到8192之间；ffplay使用1024。</p>
<p>&nbsp;<wbr><wbr> ·callback 这个是我们的回调函数。我们后面将会详细讨论。</p>
<p>&nbsp;<wbr><wbr> ·userdata 这个是SDL供给回调函数运行的参数。我们将让回调函数得到整个编解码的上下文；你将在后面知道原因。</p>
<p>&nbsp;<wbr><wbr></p>
<p>最后，我们使用SDL_OpenAudio函数来打开声音。</p>
<p>如果你还记得前面的指导，我们仍然需要打开声音编解码器本身。这是很显然的。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>AVCodec&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> *aCodec;</p>
<p>&nbsp;<wbr><wbr></p>
<p>aCodec = avcodec_find_decoder(aCodecCtx-&gt;codec_id);</p>
<p>if(!aCodec) {</p>
<p>&nbsp;<wbr><wbr> fprintf(stderr, "Unsupported codec!\n");</p>
<p>&nbsp;<wbr><wbr> return -1;</p>
<p>}</p>
<p>avcodec_open(aCodecCtx, aCodec);</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>队列</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>嗯！现在我们已经准备好从流中取出声音信息。但是我们如何来处理这些信息呢？我们将会不断地从文件中得到这些包，但同时SDL也将调用回调函数。解决方法为创建一个全局的结构体变量以便于我们从文件中得到的声音包有地方存放同时也保证SDL中的声音回调函数audio_callback能从这个地方得到声音数据。所以我们要做的是创建一个包的队列queue。在ffmpeg中有一个叫AVPacketList的结构体可以帮助我们，这个结构体实际是一串包的链表。下面就是我们的队列结构体：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>typedef struct PacketQueue {</p>
<p>&nbsp;<wbr><wbr> AVPacketList *first_pkt, *last_pkt;</p>
<p>&nbsp;<wbr><wbr> int nb_packets;</p>
<p>&nbsp;<wbr><wbr> int size;</p>
<p>&nbsp;<wbr><wbr> SDL_mutex *mutex;</p>
<p>&nbsp;<wbr><wbr> SDL_cond *cond;</p>
<p>} PacketQueue;</p>
</td>
</tr>
</tbody>
</table>
<p>首先，我们应当指出nb_packets是与size不一样的－－size表示我们从packet-&gt;size中得到的字节数。你会注意到我们有一个互斥量mutex和一个条件变量cond在结构体里面。这是因为SDL是在一个独立的线程中来进行音频处理的。如果我们没有正确的锁定这个队列，我们有可能把数据搞乱。我们将来看一个这个队列是如何来运行的。每一个程序员应当知道如何来生成的一个队列，但是我们将把这部分也来讨论从而可以学习到SDL的函数。</p>
<p>一开始我们先创建一个函数来初始化队列：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>void packet_queue_init(PacketQueue *q) {</p>
<p>&nbsp;<wbr><wbr> memset(q, 0, sizeof(PacketQueue));</p>
<p>&nbsp;<wbr><wbr> q-&gt;mutex = SDL_CreateMutex();</p>
<p>&nbsp;<wbr><wbr> q-&gt;cond = SDL_CreateCond();</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>接着我们再做一个函数来给队列中填入东西：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>int packet_queue_put(PacketQueue *q, AVPacket *pkt) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> AVPacketList *pkt1;</p>
<p>&nbsp;<wbr><wbr> if(av_dup_packet(pkt) &lt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> return -1;</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> pkt1 = av_malloc(sizeof(AVPacketList));</p>
<p>&nbsp;<wbr><wbr> if (!pkt1)</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> return -1;</p>
<p>&nbsp;<wbr><wbr> pkt1-&gt;pkt = *pkt;</p>
<p>&nbsp;<wbr><wbr> pkt1-&gt;next = NULL;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> SDL_LockMutex(q-&gt;mutex);</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> if (!q-&gt;last_pkt)</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> q-&gt;first_pkt = pkt1;</p>
<p>&nbsp;<wbr><wbr> else</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> q-&gt;last_pkt-&gt;next = pkt1;</p>
<p>&nbsp;<wbr><wbr> q-&gt;last_pkt = pkt1;</p>
<p>&nbsp;<wbr><wbr> q-&gt;nb_packets++;</p>
<p>&nbsp;<wbr><wbr> q-&gt;size += pkt1-&gt;pkt.size;</p>
<p>&nbsp;<wbr><wbr> SDL_CondSignal(q-&gt;cond);</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> SDL_UnlockMutex(q-&gt;mutex);</p>
<p>&nbsp;<wbr><wbr> return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>函数SDL_LockMutex()锁定队列的互斥量以便于我们向队列中添加东西，然后函数SDL_CondSignal()通过我们的条件变量为一个接收函数（如果它在等待）发出一个信号来告诉它现在已经有数据了，接着就会解锁互斥量并让队列可以自由访问。</p>
<p>下面是相应的接收函数。注意函数SDL_CondWait()是如何按照我们的要求让函数阻塞block的（例如一直等到队列中有数据）。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>int quit = 0;</p>
<p>&nbsp;<wbr><wbr></p>
<p>static int packet_queue_get(PacketQueue *q, AVPacket *pkt, int block) {</p>
<p>&nbsp;<wbr><wbr> AVPacketList *pkt1;</p>
<p>&nbsp;<wbr><wbr> int ret;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> SDL_LockMutex(q-&gt;mutex);</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> for(;;) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(quit) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> ret = -1;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pkt1 = q-&gt;first_pkt;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if (pkt1) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> q-&gt;first_pkt = pkt1-&gt;next;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if (!q-&gt;first_pkt)</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> q-&gt;last_pkt = NULL;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> q-&gt;nb_packets--;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> q-&gt;size -= pkt1-&gt;pkt.size;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> *pkt = pkt1-&gt;pkt;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> av_free(pkt1);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> ret = 1;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else if (!block) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> ret = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_CondWait(q-&gt;cond, q-&gt;mutex);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> SDL_UnlockMutex(q-&gt;mutex);</p>
<p>&nbsp;<wbr><wbr> return ret;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>正如你所看到的，我们已经用一个无限循环包装了这个函数以便于我们想用阻塞的方式来得到数据。我们通过使用SDL中的函数SDL_CondWait()来避免无限循环。基本上，所有的CondWait只等待从SDL_CondSignal()函数（或者SDL_CondBroadcast()函数）中发出的信号，然后再继续执行。然而，虽然看起来我们陷入了我们的互斥体中－－如果我们一直保持着这个锁，我们的函数将永远无法把数据放入到队列中去！但是，SDL_CondWait()函数也为我们做了解锁互斥量的动作然后才尝试着在得到信号后去重新锁定它。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>意外情况</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>你们将会注意到我们有一个全局变量quit，我们用它来保证还没有设置程序退出的信号（SDL会自动处理TERM类似的信号）。否则，这个线程将不停地运行直到我们使用kill -9来结束程序。FFMPEG同样也提供了一个函数来进行回调并检查我们是否需要退出一些被阻塞的函数：这个函数就是url_set_interrupt_cb。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>int decode_interrupt_cb(void) {</p>
<p>&nbsp;<wbr><wbr> return quit;</p>
<p>}</p>
<p>...</p>
<p>main() {</p>
<p>...</p>
<p>&nbsp;<wbr><wbr> url_set_interrupt_cb(decode_interrupt_cb);&nbsp;<wbr><wbr></p>
<p>...&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> SDL_PollEvent(&amp;event);</p>
<p>&nbsp;<wbr><wbr> switch(event.type) {</p>
<p>&nbsp;<wbr><wbr> case SDL_QUIT:</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> quit = 1;</p>
<p>...</p>
</td>
</tr>
</tbody>
</table>
<p>当然，这仅仅是用来给ffmpeg中的阻塞情况使用的，而不是SDL中的。我们还必需要设置quit标志为1。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>为队列提供包</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>剩下的我们唯一需要为队列所做的事就是提供包了：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>PacketQueue audioq;</p>
<p>main() {</p>
<p>...</p>
<p>&nbsp;<wbr><wbr> avcodec_open(aCodecCtx, aCodec);</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> packet_queue_init(&amp;audioq);</p>
<p>&nbsp;<wbr><wbr> SDL_PauseAudio(0);</p>
</td>
</tr>
</tbody>
</table>
<p>函数SDL_PauseAudio()让音频设备最终开始工作。如果没有立即供给足够的数据，它会播放静音。</p>
<p>&nbsp;<wbr><wbr></p>
<p>我们已经建立好我们的队列，现在我们准备为它提供包。先看一下我们的读取包的循环：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>while(av_read_frame(pFormatCtx, &amp;packet)&gt;=0) {</p>
<p>&nbsp;<wbr><wbr> // Is this a packet from the video stream?</p>
<p>&nbsp;<wbr><wbr> if(packet.stream_index==videoStream) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // Decode video frame</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> ....</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> } else if(packet.stream_index==audioStream) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> packet_queue_put(&amp;audioq, &amp;packet);</p>
<p>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> av_free_packet(&amp;packet);</p>
<p>&nbsp;<wbr><wbr> }</p>
</td>
</tr>
</tbody>
</table>
<p>注意：我们没有在把包放到队列里的时候释放它，我们将在解码后来释放它。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>取出包</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>现在，让我们最后让声音回调函数audio_callback来从队列中取出包。回调函数的格式必需为void callback(void *userdata, Uint8 *stream, int len)，这里的userdata就是我们给到SDL的指针，stream是我们要把声音数据写入的缓冲区指针，len是缓冲区的大小。下面就是代码：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>void audio_callback(void *userdata, Uint8 *stream, int len) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> AVCodecContext *aCodecCtx = (AVCodecContext *)userdata;</p>
<p>&nbsp;<wbr><wbr> int len1, audio_size;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> static uint8_t audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * 3) / 2];</p>
<p>&nbsp;<wbr><wbr> static unsigned int audio_buf_size = 0;</p>
<p>&nbsp;<wbr><wbr> static unsigned int audio_buf_index = 0;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> while(len &gt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(audio_buf_index &gt;= audio_buf_size) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> audio_size = audio_decode_frame(aCodecCtx, audio_buf,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>
 sizeof(audio_buf));</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(audio_size &lt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> audio_buf_size = 1024;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> memset(audio_buf, 0, audio_buf_size);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> audio_buf_size = audio_size;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> audio_buf_index = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> len1 = audio_buf_size - audio_buf_index;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(len1 &gt; len)</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr>len1 = len;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> memcpy(stream, (uint8_t *)audio_buf + audio_buf_index, len1);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> len -= len1;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> stream += len1;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> audio_buf_index += len1;</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>这基本上是一个简单的从另外一个我们将要写的audio_decode_frame()函数中获取数据的循环，这个循环把结果写入到中间缓冲区，尝试着向流中写入len字节并且在我们没有足够的数据的时候会获取更多的数据或者当我们有多余数据的时候保存下来为后面使用。这个audio_buf的大小为 1.5倍的声音帧的大小以便于有一个比较好的缓冲，这个声音帧的大小是ffmpeg给出的。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>最后解码音频</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>让我们看一下解码器的真正部分：audio_decode_frame</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>int audio_decode_frame(AVCodecContext *aCodecCtx, uint8_t *audio_buf,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> int buf_size)
 {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> static AVPacket pkt;</p>
<p>&nbsp;<wbr><wbr> static uint8_t *audio_pkt_data = NULL;</p>
<p>&nbsp;<wbr><wbr> static int audio_pkt_size = 0;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> int len1, data_size;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> for(;;) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> while(audio_pkt_size &gt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> data_size = buf_size;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> len1 = avcodec_decode_audio2(aCodecCtx, (int16_t *)audio_buf, &amp;data_size,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr> audio_pkt_data, audio_pkt_size);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(len1 &lt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> audio_pkt_size = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> audio_pkt_data += len1;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> audio_pkt_size -= len1;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(data_size &lt;= 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> continue;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> return data_size;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(pkt.data)</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> av_free_packet(&amp;pkt);</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr>&nbsp;<wbr><wbr>if(quit) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> return -1;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(packet_queue_get(&amp;audioq, &amp;pkt, 1) &lt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> return -1;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> audio_pkt_data = pkt.data;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> audio_pkt_size = pkt.size;</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>整个过程实际上从函数的尾部开始，在这里我们调用了packet_queue_get()函数。我们从队列中取出包，并且保存它的信息。然后，一旦我们有了可以使用的包，我们就调用函数avcodec_decode_audio2()，它的功能就像它的姐妹函数 avcodec_decode_video()一样，唯一的区别是它的一个包里可能有不止一个声音帧，所以你可能要调用很多次来解码出包中所有的数据。同时也要记住进行指针audio_buf的强制转换，因为SDL给出的是8位整型缓冲指针而ffmpeg给出的数据是16位的整型指针。你应该也会注意到
 len1和data_size的不同，len1表示解码使用的数据的在包中的大小，data_size表示实际返回的原始声音数据的大小。</p>
<p>当我们得到一些数据的时候，我们立刻返回来看一下是否仍然需要从队列中得到更加多的数据或者我们已经完成了。如果我们仍然有更加多的数据要处理，我们把它保存到下一次。如果我们完成了一个包的处理，我们最后要释放它。</p>
<p>就是这样。我们利用主的读取队列循环从文件得到音频并送到队列中，然后被audio_callback函数从队列中读取并处理，最后把数据送给SDL，于是SDL就相当于我们的声卡。让我们继续并且编译：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>gcc -o tutorial03 tutorial03.c -lavutil -lavformat -lavcodec -lz -lm \</p>
<p>`sdl-config --cflags --libs`</p>
</td>
</tr>
</tbody>
</table>
<p>啊哈！视频虽然还是像原来那样快，但是声音可以正常播放了。这是为什么呢？因为声音信息中的采样率－－虽然我们把声音数据尽可能快的填充到声卡缓冲中，但是声音设备却会按照原来指定的采样率来进行播放。</p>
<p>我们几乎已经准备好来开始同步音频和视频了，但是首先我们需要的是一点程序的组织。用队列的方式来组织和播放音频在一个独立的线程中工作的很好：它使得程序更加更加易于控制和模块化。在我们开始同步音视频之前，我们需要让我们的代码更加容易处理。所以下次要讲的是：创建一个线程。</p>
<p><br>
</p>
<p>--</p>
<h2><a name="t2"></a>ffmpeg文档4</h2>
<span>(2008-08-26 23:18:50)</span>
<div><a><cite><img title="ffmpeg文档12345678" height="15" alt="ffmpeg文档12345678" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/sg_trans.gif" width="15" align="absMiddle">转载</cite></a></div>
<div>
<table>
<tbody>
<tr>
<td><span>标签：</span>
<h3><a name="t3"></a><a href="http://uni.sina.com.cn/c.php?t=blog&amp;k=%EF%BF%BD%EF%BF%BD%CC%B8&amp;ts=bpost&amp;stype=tag" target="_blank">杂谈</a></h3>
</td>
<td><span>分类：</span> <a href="http://blog.sina.com.cn/s/articlelist_1188849065_1_1.html" target="_blank">
翻译文档</a></td>
</tr>
</tbody>
</table>
</div>
<div>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // Is this a packet from the video stream?</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(packet-&gt;stream_index == is-&gt;videoStream) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> packet_queue_put(&amp;is-&gt;videoq, packet);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else if(packet-&gt;stream_index == is-&gt;audioStream) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> packet_queue_put(&amp;is-&gt;audioq, packet);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> av_free_packet(packet);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>这里没有什么新东西，除了我们给音频和视频队列限定了一个最大值并且我们添加一个检测读错误的函数。格式上下文里面有一个叫做pb的 ByteIOContext类型结构体。这个结构体是用来保存一些低级的文件信息。函数url_ferror用来检测结构体并发现是否有些读取文件错误。</p>
<p>在循环以后，我们的代码是用等待其余的程序结束和提示我们已经结束的。这些代码是有益的，因为它指示出了如何驱动事件－－后面我们将显示影像。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr> while(!is-&gt;quit) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_Delay(100);</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>fail:</p>
<p>&nbsp;<wbr><wbr> if(1){</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_Event event;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> event.type = FF_QUIT_EVENT;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> event.user.data1 = is;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_PushEvent(&amp;event);</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> return 0;</p>
</td>
</tr>
</tbody>
</table>
<p>我们使用SDL常量SDL_USEREVENT来从用户事件中得到值。第一个用户事件的值应当是SDL_USEREVENT，下一个是 SDL_USEREVENT＋1并且依此类推。在我们的程序中FF_QUIT_EVENT被定义成SDL_USEREVENT＋2。如果喜欢，我们也可以传递用户数据，在这里我们传递的是大结构体的指针。最后我们调用SDL_PushEvent()函数。在我们的事件分支中，我们只是像以前放入 SDL_QUIT_EVENT部分一样。我们将在自己的事件队列中详细讨论，现在只是确保我们正确放入了FF_QUIT_EVENT事件，我们将在后面捕捉到它并且设置我们的退出标志quit。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>得到帧：video_thread</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>当我们准备好解码器后，我们开始视频线程。这个线程从视频队列中读取包，把它解码成视频帧，然后调用queue_picture函数把处理好的帧放入到图片队列中:</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>int video_thread(void *arg) {</p>
<p>&nbsp;<wbr><wbr> VideoState *is = (VideoState *)arg;</p>
<p>&nbsp;<wbr><wbr> AVPacket pkt1, *packet = &amp;pkt1;</p>
<p>&nbsp;<wbr><wbr> int len1, frameFinished;</p>
<p>&nbsp;<wbr><wbr> AVFrame *pFrame;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> pFrame = avcodec_alloc_frame();</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> for(;;) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(packet_queue_get(&amp;is-&gt;videoq, packet, 1) &lt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // means we quit getting packets</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // Decode video frame</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> len1 = avcodec_decode_video(is-&gt;video_st-&gt;codec, pFrame, &amp;frameFinished,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> packet-&gt;data, packet-&gt;size);</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // Did we get a video frame?</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(frameFinished) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(queue_picture(is, pFrame) &lt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> av_free_packet(packet);</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> av_free(pFrame);</p>
<p>&nbsp;<wbr><wbr> return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>在这里的很多函数应该很熟悉吧。我们把avcodec_decode_video函数移到了这里，替换了一些参数，例如：我们把AVStream保存在我们自己的大结构体中，所以我们可以从那里得到编解码器的信息。我们仅仅是不断的从视频队列中取包一直到有人告诉我们要停止或者出错为止。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>把帧队列化</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>让我们看一下保存解码后的帧pFrame到图像队列中去的函数。因为我们的图像队列是SDL的覆盖的集合（基本上不用让视频显示函数再做计算了），我们需要把帧转换成相应的格式。我们保存到图像队列中的数据是我们自己做的一个结构体。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>typedef struct VideoPicture {</p>
<p>&nbsp;<wbr><wbr> SDL_Overlay *bmp;</p>
<p>&nbsp;<wbr><wbr> int width, height;</p>
<p>&nbsp;<wbr><wbr> int allocated;</p>
<p>} VideoPicture;</p>
</td>
</tr>
</tbody>
</table>
<p>我们的大结构体有一个可以保存这些缓冲区。然而，我们需要自己来申请SDL_Overlay（注意：allocated标志会指明我们是否已经做了这个申请的动作与否）。</p>
<p>为了使用这个队列，我们有两个指针－－写入指针和读取指针。我们也要保证一定数量的实际数据在缓冲中。要写入到队列中，我们先要等待缓冲清空以便于有位置来保存我们的VideoPicture。然后我们检查看我们是否已经申请到了一个可以写入覆盖的索引号。如果没有，我们要申请一段空间。我们也要重新申请缓冲如果窗口的大小已经改变。然而，为了避免被锁定，尽是避免在这里申请（我现在还不太清楚原因；我相信是为了避免在其它线程中调用SDL覆盖函数的原因）。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>int queue_picture(VideoState *is, AVFrame *pFrame) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> VideoPicture *vp;</p>
<p>&nbsp;<wbr><wbr> int dst_pix_fmt;</p>
<p>&nbsp;<wbr><wbr> AVPicture pict;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> SDL_LockMutex(is-&gt;pictq_mutex);</p>
<p>&nbsp;<wbr><wbr> while(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> !is-&gt;quit) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> SDL_UnlockMutex(is-&gt;pictq_mutex);</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> if(is-&gt;quit)</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> return -1;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> // windex is set to 0 initially</p>
<p>&nbsp;<wbr><wbr> vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> if(!vp-&gt;bmp ||</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> vp-&gt;width != is-&gt;video_st-&gt;codec-&gt;width ||</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> vp-&gt;height != is-&gt;video_st-&gt;codec-&gt;height) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_Event event;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> vp-&gt;allocated = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> event.type = FF_ALLOC_EVENT;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> event.user.data1 = is;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_PushEvent(&amp;event);</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_LockMutex(is-&gt;pictq_mutex);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> while(!vp-&gt;allocated &amp;&amp; !is-&gt;quit) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_UnlockMutex(is-&gt;pictq_mutex);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(is-&gt;quit) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> return -1;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> }</p>
</td>
</tr>
</tbody>
</table>
<p>这里的事件机制与前面我们想要退出的时候看到的一样。我们已经定义了事件FF_ALLOC_EVENT作为SDL_USEREVENT。我们把事件发到事件队列中然后等待申请内存的函数设置好条件变量。</p>
<p>让我们来看一看如何来修改事件循环：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>for(;;) {</p>
<p>&nbsp;<wbr><wbr> SDL_WaitEvent(&amp;event);</p>
<p>&nbsp;<wbr><wbr> switch(event.type) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> case FF_ALLOC_EVENT:</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> alloc_picture(event.user.data1);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
</td>
</tr>
</tbody>
</table>
<p>记住event.user.data1是我们的大结构体。就这么简单。让我们看一下alloc_picture()函数：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>void alloc_picture(void *userdata) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> VideoState *is = (VideoState *)userdata;</p>
<p>&nbsp;<wbr><wbr> VideoPicture *vp;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</p>
<p>&nbsp;<wbr><wbr> if(vp-&gt;bmp) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // we already have one make another, bigger/smaller</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_FreeYUVOverlay(vp-&gt;bmp);</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> // Allocate a place to put our YUV image on that screen</p>
<p>&nbsp;<wbr><wbr> vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_st-&gt;codec-&gt;width,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr>is-&gt;video_st-&gt;codec-&gt;height,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr>SDL_YV12_OVERLAY,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr>screen);</p>
<p>&nbsp;<wbr><wbr> vp-&gt;width = is-&gt;video_st-&gt;codec-&gt;width;</p>
<p>&nbsp;<wbr><wbr> vp-&gt;height = is-&gt;video_st-&gt;codec-&gt;height;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> SDL_LockMutex(is-&gt;pictq_mutex);</p>
<p>&nbsp;<wbr><wbr> vp-&gt;allocated = 1;</p>
<p>&nbsp;<wbr><wbr> SDL_CondSignal(is-&gt;pictq_cond);</p>
<p>&nbsp;<wbr><wbr> SDL_UnlockMutex(is-&gt;pictq_mutex);</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>你可以看到我们把SDL_CreateYUVOverlay函数从主循环中移到了这里。这段代码应该完全可以自我注释。记住我们把高度和宽度保存到VideoPicture结构体中因为我们需要保存我们的视频的大小没有因为某些原因而改变。</p>
<p>好，我们几乎已经全部解决并且可以申请到YUV覆盖和准备好接收图像。让我们回顾一下queue_picture并看一个拷贝帧到覆盖的代码。你应该能认出其中的一部分：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>int queue_picture(VideoState *is, AVFrame *pFrame) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> if(vp-&gt;bmp) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_LockYUVOverlay(vp-&gt;bmp);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> dst_pix_fmt = PIX_FMT_YUV420P;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.data[0] = vp-&gt;bmp-&gt;pixels[0];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.data[1] = vp-&gt;bmp-&gt;pixels[2];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.data[2] = vp-&gt;bmp-&gt;pixels[1];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.linesize[0] = vp-&gt;bmp-&gt;pitches[0];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.linesize[1] = vp-&gt;bmp-&gt;pitches[2];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.linesize[2] = vp-&gt;bmp-&gt;pitches[1];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // Convert the image into YUV format that SDL uses</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> img_convert(&amp;pict, dst_pix_fmt,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> (AVPicture *)pFrame, is-&gt;video_st-&gt;codec-&gt;pix_fmt,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;video_st-&gt;codec-&gt;width, is-&gt;video_st-&gt;codec-&gt;height);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_UnlockYUVOverlay(vp-&gt;bmp);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;pictq_windex = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_LockMutex(is-&gt;pictq_mutex);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;pictq_size++;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_UnlockMutex(is-&gt;pictq_mutex);</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>这部分代码和前面用到的一样，主要是简单的用我们的帧来填充YUV覆盖。最后一点只是简单的给队列加1。这个队列在写的时候会一直写入到满为止，在读的时候会一直读空为止。因此所有的都依赖于is-&gt;pictq_size值，这要求我们必需要锁定它。这里我们做的是增加写指针（在必要的时候采用轮转的方式），然后锁定队列并且增加尺寸。现在我们的读者函数将会知道队列中有了更多的信息，当队列满的时候，我们的写入函数也会知道。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>显示视频</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>这就是我们的视频线程。现在我们看过了几乎所有的线程除了一个－－记得我们调用schedule_refresh()函数吗？让我们看一下实际中是如何做的：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr></p>
<p>static void schedule_refresh(VideoState *is, int delay) {</p>
<p>&nbsp;<wbr><wbr> SDL_AddTimer(delay, sdl_refresh_timer_cb, is);</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>函数SDL_AddTimer()是SDL中的一个定时（特定的毫秒）执行用户定义的回调函数（可以带一些参数user data）的简单函数。我们将用这个函数来定时刷新视频－－每次我们调用这个函数的时候，它将设置一个定时器来触发定时事件来把一帧从图像队列中显示到屏幕上。</p>
<p>但是，让我们先触发那个事件。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>static Uint32 sdl_refresh_timer_cb(Uint32 interval, void *opaque) {</p>
<p>&nbsp;<wbr><wbr> SDL_Event event;</p>
<p>&nbsp;<wbr><wbr> event.type = FF_REFRESH_EVENT;</p>
<p>&nbsp;<wbr><wbr> event.user.data1 = opaque;</p>
<p>&nbsp;<wbr><wbr> SDL_PushEvent(&amp;event);</p>
<p>&nbsp;<wbr><wbr> return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>这里向队列中写入了一个现在很熟悉的事件。FF_REFRESH_EVENT被定义成SDL_USEREVENT+1。要注意的一件事是当返回0的时候，SDL停止定时器，于是回调就不会再发生。</p>
<p>现在我们产生了一个FF_REFRESH_EVENT事件，我们需要在事件循环中处理它：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>for(;;) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> SDL_WaitEvent(&amp;event);</p>
<p>&nbsp;<wbr><wbr> switch(event.type) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> case FF_REFRESH_EVENT:</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> video_refresh_timer(event.user.data1);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
</td>
</tr>
</tbody>
</table>
<p>于是我们就运行到了这个函数，在这个函数中会把数据从图像队列中取出：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>void video_refresh_timer(void *userdata) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> VideoState *is = (VideoState *)userdata;</p>
<p>&nbsp;<wbr><wbr> VideoPicture *vp;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> if(is-&gt;video_st) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(is-&gt;pictq_size == 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> schedule_refresh(is, 1);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> schedule_refresh(is, 80);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> video_display(is);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;pictq_rindex = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_LockMutex(is-&gt;pictq_mutex);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;pictq_size--;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_CondSignal(is-&gt;pictq_cond);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_UnlockMutex(is-&gt;pictq_mutex);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> schedule_refresh(is, 100);</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>现在，这只是一个极其简单的函数：当队列中有数据的时候，他从其中获得数据，为下一帧设置定时器，调用video_display函数来真正显示图像到屏幕上，然后把队列读索引值加1，并且把队列的尺寸size减1。你可能会注意到在这个函数中我们并没有真正对vp做一些实际的动作，原因是这样的：我们将在后面处理。我们将在后面同步音频和视频的时候用它来访问时间信息。你会在这里看到这个注释信息“timing密码here”。那里我们将讨论什么时候显示下一帧视频，然后把相应的值写入到schedule_refresh()函数中。现在我们只是随便写入一个值80。从技术上来讲，你可以猜测并验证这个值，并且为每个电影重新编译程序，但是：1）过一段时间它会漂移；2）这种方式是很笨的。我们将在后面来讨论它。</p>
<p>我们几乎做完了；我们仅仅剩了最后一件事：显示视频！下面就是video_display函数：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>void video_display(VideoState *is) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> SDL_Rect rect;</p>
<p>&nbsp;<wbr><wbr> VideoPicture *vp;</p>
<p>&nbsp;<wbr><wbr> AVPicture pict;</p>
<p>&nbsp;<wbr><wbr> float aspect_ratio;</p>
<p>&nbsp;<wbr><wbr> int w, h, x, y;</p>
<p>&nbsp;<wbr><wbr> int i;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</p>
<p>&nbsp;<wbr><wbr> if(vp-&gt;bmp) {</p>
<p>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr>&nbsp;<wbr><wbr>if(is-&gt;video_st-&gt;codec-&gt;sample_aspect_ratio.num == 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> aspect_ratio = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> aspect_ratio = av_q2d(is-&gt;video_st-&gt;codec-&gt;sample_aspect_ratio) *</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;video_st-&gt;codec-&gt;width / is-&gt;video_st-&gt;codec-&gt;height;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(aspect_ratio &lt;= 0.0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> aspect_ratio = (float)is-&gt;video_st-&gt;codec-&gt;width /</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> (float)is-&gt;video_st-&gt;codec-&gt;height;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> h = screen-&gt;h;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> w = ((int)rint(h * aspect_ratio)) &amp; -3;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(w &gt; screen-&gt;w) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> w = screen-&gt;w;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> h = ((int)rint(w / aspect_ratio)) &amp; -3;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> x = (screen-&gt;w - w) / 2;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> y = (screen-&gt;h - h) / 2;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> rect.x = x;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> rect.y = y;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> rect.w = w;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> rect.h = h;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>因为我们的屏幕可以是任意尺寸（我们设置为640x480并且用户可以自己来改变尺寸），我们需要动态计算出我们显示的图像的矩形大小。所以一开始我们需要计算出电影的纵横比aspect ratio，表示方式为宽度除以高度。某些编解码器会有奇数采样纵横比，只是简单表示了一个像素或者一个采样的宽度除以高度的比例。因为宽度和高度在我们的编解码器中是用像素为单位的，所以实际的纵横比与纵横比乘以样本纵横比相同。某些编解码器会显示纵横比为0，这表示每个像素的纵横比为1x1。然后我们把电影缩放到适合屏幕的尽可能大的尺寸。这里的&amp;
 -3表示与-3做与运算，实际上是让它们4字节对齐。然后我们把电影移到中心位置，接着调用SDL_DisplayYUVOverlay()函数。</p>
<p>结果是什么？我们做完了吗？嗯，我们仍然要重新改写声音部分的代码来使用新的VideoStruct结构体，但是那些只是尝试着改变，你可以看一下那些参考示例代码。最后我们要做的是改变ffmpeg提供的默认退出回调函数为我们的退出回调函数。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>VideoState *global_video_state;</p>
<p>&nbsp;<wbr><wbr></p>
<p>int decode_interrupt_cb(void) {</p>
<p>&nbsp;<wbr><wbr> return (global_video_state &amp;&amp; global_video_state-&gt;quit);</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>我们在主函数中为大结构体设置了global_video_state。</p>
<p>这就是了！让我们编译它：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>gcc -o tutorial04 tutorial04.c -lavutil -lavformat -lavcodec -lz -lm \</p>
<p>`sdl-config --cflags --libs`</p>
</td>
</tr>
</tbody>
</table>
<p>请享受一下没有经过同步的电影！下次我们将编译一个可以最终工作的电影播放器</p>
</div>
<h2><a name="t4"></a>ffmpeg文档5</h2>
<span>(2008-08-26 23:21:41)</span>
<div><a><cite><img title="ffmpeg文档12345678" height="15" alt="ffmpeg文档12345678" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/sg_trans.gif" width="15" align="absMiddle">转载</cite></a></div>
<div>
<table>
<tbody>
<tr>
<td><span>标签：</span>
<h3><a name="t5"></a><a href="http://uni.sina.com.cn/c.php?t=blog&amp;k=%EF%BF%BD%EF%BF%BD%CC%B8&amp;ts=bpost&amp;stype=tag" target="_blank">杂谈</a></h3>
</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<div>
<p align="center"><strong>指导5：同步视频</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>如何同步视频</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>前面整个的一段时间，我们有了一个几乎无用的电影播放器。当然，它能播放视频，也能播放音频，但是它还不能被称为一部电影。那么我们还要做什么呢？</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>PTS和DTS</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>幸运的是，音频和视频流都有一些关于以多快速度和什么时间来播放它们的信息在里面。音频流有采样，视频流有每秒的帧率。然而，如果我们只是简单的通过数帧和乘以帧率的方式来同步视频，那么就很有可能会失去同步。于是作为一种补充，在流中的包有种叫做DTS（解码时间戳）和PTS（显示时间戳）的机制。为了这两个参数，你需要了解电影存放的方式。像MPEG等格式，使用被叫做B帧（B表示双向bidrectional）的方式。另外两种帧被叫做I帧和P帧（I表示关键帧，P表示预测帧）。I帧包含了某个特定的完整图像。P帧依赖于前面的I帧和P帧并且使用比较或者差分的方式来编码。B帧与P帧有点类似，但是它是依赖于前面和后面的帧的信息的。这也就解释了为什么我们可能在调用avcodec_decode_video以后会得不到一帧图像。</p>
<p>所以对于一个电影，帧是这样来显示的：I B B P。现在我们需要在显示B帧之前知道P帧中的信息。因此，帧可能会按照这样的方式来存储：IPBB。这就是为什么我们会有一个解码时间戳和一个显示时间戳的原因。解码时间戳告诉我们什么时候需要解码，显示时间戳告诉我们什么时候需要显示。所以，在这种情况下，我们的流可以是这样的：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> PTS: 1 4 2 3</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> DTS: 1 2 3 4</p>
<p>Stream: I P B B</p>
</td>
</tr>
</tbody>
</table>
<p>通常PTS和DTS只有在流中有B帧的时候会不同。</p>
<p>&nbsp;<wbr><wbr></p>
<p>当我们调用av_read_frame()得到一个包的时候，PTS和DTS的信息也会保存在包中。但是我们真正想要的PTS是我们刚刚解码出来的原始帧的PTS，这样我们才能知道什么时候来显示它。然而，我们从avcodec_decode_video()函数中得到的帧只是一个AVFrame，其中并没有包含有用的PTS值（注意：AVFrame并没有包含时间戳信息，但当我们等到帧的时候并不是我们想要的样子）。然而，ffmpeg重新排序包以便于被avcodec_decode_video()函数处理的包的DTS可以总是与其返回的PTS相同。但是，另外的一个警告是：我们也并不是总能得到这个信息。</p>
<p>不用担心，因为有另外一种办法可以找到帖的PTS，我们可以让程序自己来重新排序包。我们保存一帧的第一个包的PTS：这将作为整个这一帧的PTS。我们可以通过函数avcodec_decode_video()来计算出哪个包是一帧的第一个包。怎样实现呢？任何时候当一个包开始一帧的时候，avcodec_decode_video()将调用一个函数来为一帧申请一个缓冲。当然，ffmpeg允许我们重新定义那个分配内存的函数。所以我们制作了一个新的函数来保存一个包的时间戳。</p>
<p>当然，尽管那样，我们可能还是得不到一个正确的时间戳。我们将在后面处理这个问题。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>同步</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>现在，知道了什么时候来显示一个视频帧真好，但是我们怎样来实际操作呢？这里有个主意：当我们显示了一帧以后，我们计算出下一帧显示的时间。然后我们简单的设置一个新的定时器来。你可能会想，我们检查下一帧的PTS值而不是系统时钟来看超时是否会到。这种方式可以工作，但是有两种情况要处理。</p>
<p>首先，要知道下一个PTS是什么。现在我们能添加视频速率到我们的PTS中－－太对了！然而，有些电影需要帧重复。这意味着我们重复播放当前的帧。这将导致程序显示下一帧太快了。所以我们需要计算它们。</p>
<p>第二，正如程序现在这样，视频和音频播放很欢快，一点也不受同步的影响。如果一切都工作得很好的话，我们不必担心。但是，你的电脑并不是最好的，很多视频文件也不是完好的。所以，我们有三种选择：同步音频到视频，同步视频到音频，或者都同步到外部时钟（例如你的电脑时钟）。从现在开始，我们将同步视频到音频。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>写代码：获得帧的时间戳</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>现在让我们到代码中来做这些事情。我们将需要为我们的大结构体添加一些成员，但是我们会根据需要来做。首先，让我们看一下视频线程。记住，在这里我们得到了解码线程输出到队列中的包。这里我们需要的是从avcodec_decode_video函数中得到帧的时间戳。我们讨论的第一种方式是从上次处理的包中得到DTS，这是很容易的：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr> double pts;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> for(;;) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(packet_queue_get(&amp;is-&gt;videoq, packet, 1) &lt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // means we quit getting packets</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pts = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // Decode video frame</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> len1 = avcodec_decode_video(is-&gt;video_st-&gt;codec,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>
 pFrame, &amp;frameFinished,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> packet-&gt;data, packet-&gt;size);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(packet-&gt;dts != AV_NOPTS_VALUE) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pts = packet-&gt;dts;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pts = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pts *= av_q2d(is-&gt;video_st-&gt;time_base);</p>
</td>
</tr>
</tbody>
</table>
<p>如果我们得不到PTS就把它设置为0。</p>
<p>好，那是很容易的。但是我们所说的如果包的DTS不能帮到我们，我们需要使用这一帧的第一个包的PTS。我们通过让ffmpeg使用我们自己的申请帧程序来实现。下面的是函数的格式：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>int get_buffer(struct AVCodecContext *c, AVFrame *pic);</p>
<p>void release_buffer(struct AVCodecContext *c, AVFrame *pic);</p>
</td>
</tr>
</tbody>
</table>
<p>申请函数没有告诉我们关于包的任何事情，所以我们要自己每次在得到一个包的时候把PTS保存到一个全局变量中去。我们自己以读到它。然后，我们把值保存到AVFrame结构体难理解的变量中去。所以一开始，这就是我们的函数：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>uint64_t global_video_pkt_pts = AV_NOPTS_VALUE;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p>int our_get_buffer(struct AVCodecContext *c, AVFrame *pic) {</p>
<p>&nbsp;<wbr><wbr> int ret = avcodec_default_get_buffer(c, pic);</p>
<p>&nbsp;<wbr><wbr> uint64_t *pts = av_malloc(sizeof(uint64_t));</p>
<p>&nbsp;<wbr><wbr> *pts = global_video_pkt_pts;</p>
<p>&nbsp;<wbr><wbr> pic-&gt;opaque = pts;</p>
<p>&nbsp;<wbr><wbr> return ret;</p>
<p>}</p>
<p>void our_release_buffer(struct AVCodecContext *c, AVFrame *pic) {</p>
<p>&nbsp;<wbr><wbr> if(pic) av_freep(&amp;pic-&gt;opaque);</p>
<p>&nbsp;<wbr><wbr> avcodec_default_release_buffer(c, pic);</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>函数avcodec_default_get_buffer和avcodec_default_release_buffer是ffmpeg中默认的申请缓冲的函数。函数av_freep是一个内存管理函数，它不但把内存释放而且把指针设置为NULL。</p>
<p>现在到了我们流打开的函数（stream_component_open），我们添加这几行来告诉ffmpeg如何去做：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> codecCtx-&gt;get_buffer = our_get_buffer;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> codecCtx-&gt;release_buffer = our_release_buffer;</p>
</td>
</tr>
</tbody>
</table>
<p>现在我们必需添加代码来保存PTS到全局变量中，然后在需要的时候来使用它。我们的代码现在看起来应该是这样子：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr> for(;;) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(packet_queue_get(&amp;is-&gt;videoq, packet, 1) &lt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // means we quit getting packets</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pts = 0;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // Save global pts to be stored in pFrame in first call</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> global_video_pkt_pts = packet-&gt;pts;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // Decode video frame</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> len1 = avcodec_decode_video(is-&gt;video_st-&gt;codec, pFrame, &amp;frameFinished,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> packet-&gt;data, packet-&gt;size);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(packet-&gt;dts == AV_NOPTS_VALUE</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &amp;&amp; pFrame-&gt;opaque &amp;&amp; *(uint64_t*)pFrame-&gt;opaque != AV_NOPTS_VALUE) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pts = *(uint64_t *)pFrame-&gt;opaque;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else if(packet-&gt;dts != AV_NOPTS_VALUE) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pts = packet-&gt;dts;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pts = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pts *= av_q2d(is-&gt;video_st-&gt;time_base);</p>
</td>
</tr>
</tbody>
</table>
<p>技术提示：你可能已经注意到我们使用int64来表示PTS。这是因为PTS是以整型来保存的。这个值是一个时间戳相当于时间的度量，用来以流的 time_base为单位进行时间度量。例如，如果一个流是24帧每秒，值为42的PTS表示这一帧应该排在第42个帧的位置如果我们每秒有24帧（这里并不完全正确）。</p>
<p>我们可以通过除以帧率来把这个值转化为秒。流中的time_base值表示1/framerate（对于固定帧率来说），所以得到了以秒为单位的PTS，我们需要乘以time_base。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>写代码：使用PTS来同步</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>现在我们得到了PTS。我们要注意前面讨论到的两个同步问题。我们将定义一个函数叫做synchronize_video，它可以更新同步的PTS。这个函数也能最终处理我们得不到PTS的情况。同时我们要知道下一帧的时间以便于正确设置刷新速率。我们可以使用内部的反映当前视频已经播放时间的时钟 video_clock来完成这个功能。我们把这些值添加到大结构体中。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>typedef struct VideoState {</p>
<p>&nbsp;<wbr><wbr> double&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> video_clock; ///</p>
</td>
</tr>
</tbody>
</table>
<p>下面的是函数synchronize_video，它可以很好的自我注释：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>double synchronize_video(VideoState *is, AVFrame *src_frame, double pts) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> double frame_delay;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> if(pts != 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;video_clock = pts;</p>
<p>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pts = is-&gt;video_clock;</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> frame_delay = av_q2d(is-&gt;video_st-&gt;codec-&gt;time_base);</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> frame_delay += src_frame-&gt;repeat_pict * (frame_delay * 0.5);</p>
<p>&nbsp;<wbr><wbr> is-&gt;video_clock += frame_delay;</p>
<p>&nbsp;<wbr><wbr> return pts;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>你也会注意到我们也计算了重复的帧。</p>
<p>&nbsp;<wbr><wbr></p>
<p>现在让我们得到正确的PTS并且使用queue_picture来队列化帧，添加一个新的时间戳参数pts：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // Did we get a video frame?</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(frameFinished) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pts = synchronize_video(is, pFrame, pts);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(queue_picture(is, pFrame, pts) &lt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
</td>
</tr>
</tbody>
</table>
<p>对于queue_picture来说唯一改变的事情就是我们把时间戳值pts保存到VideoPicture结构体中，我们我们必需添加一个时间戳变量到结构体中并且添加一行代码：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>typedef struct VideoPicture {</p>
<p>&nbsp;<wbr><wbr> ...</p>
<p>&nbsp;<wbr><wbr> double pts;</p>
<p>}</p>
<p>int queue_picture(VideoState *is, AVFrame *pFrame, double pts) {</p>
<p>&nbsp;<wbr><wbr> ... stuff ...</p>
<p>&nbsp;<wbr><wbr> if(vp-&gt;bmp) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> ... convert picture ...</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> vp-&gt;pts = pts;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> ... alert queue ...</p>
<p>&nbsp;<wbr><wbr> }</p>
</td>
</tr>
</tbody>
</table>
<p>现在我们的图像队列中的所有图像都有了正确的时间戳值，所以让我们看一下视频刷新函数。你会记得上次我们用80ms的刷新时间来欺骗它。那么，现在我们将会算出实际的值。</p>
<p>我们的策略是通过简单计算前一帧和现在这一帧的时间戳来预测出下一个时间戳的时间。同时，我们需要同步视频到音频。我们将设置一个音频时间audio clock；一个内部值记录了我们正在播放的音频的位置。就像从任意的mp3播放器中读出来的数字一样。既然我们把视频同步到音频，视频线程使用这个值来算出是否太快还是太慢。</p>
<p>我们将在后面来实现这些代码；现在我们假设我们已经有一个可以给我们音频时间的函数get_audio_clock。一旦我们有了这个值，我们在音频和视频失去同步的时候应该做些什么呢？简单而有点笨的办法是试着用跳过正确帧或者其它的方式来解决。作为一种替代的手段，我们会调整下次刷新的值；如果时间戳太落后于音频时间，我们加倍计算延迟。如果时间戳太领先于音频时间，我们将尽可能快的刷新。既然我们有了调整过的时间和延迟，我们将把它和我们通过 frame_timer计算出来的时间进行比较。这个帧时间frame_timer将会统计出电影播放中所有的延时。换句话说，这个
 frame_timer就是指我们什么时候来显示下一帧。我们简单的添加新的帧定时器延时，把它和电脑的系统时间进行比较，然后使用那个值来调度下一次刷新。这可能有点难以理解，所以请认真研究代码：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>void video_refresh_timer(void *userdata) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> VideoState *is = (VideoState *)userdata;</p>
<p>&nbsp;<wbr><wbr> VideoPicture *vp;</p>
<p>&nbsp;<wbr><wbr> double actual_delay, delay, sync_threshold, ref_clock, diff;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> if(is-&gt;video_st) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(is-&gt;pictq_size == 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> schedule_refresh(is, 1);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr>delay = vp-&gt;pts - is-&gt;frame_last_pts;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(delay &lt;= 0 || delay &gt;= 1.0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> delay = is-&gt;frame_last_delay;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;frame_last_delay = delay;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;frame_last_pts = vp-&gt;pts;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> ref_clock = get_audio_clock(is);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> diff = vp-&gt;pts - ref_clock;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(fabs(diff) &lt; AV_NOSYNC_THRESHOLD) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(diff &lt;= -sync_threshold) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr> delay = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else if(diff &gt;= sync_threshold) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr> delay = 2 * delay;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;frame_timer += delay;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> actual_delay = is-&gt;frame_timer - (av_gettime() / 1000000.0);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(actual_delay &lt; 0.010) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> actual_delay = 0.010;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> schedule_refresh(is, (int)(actual_delay * 1000 + 0.5));</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> video_display(is);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;pictq_rindex = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_LockMutex(is-&gt;pictq_mutex);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;pictq_size--;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_CondSignal(is-&gt;pictq_cond);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_UnlockMutex(is-&gt;pictq_mutex);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> schedule_refresh(is, 100);</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>我们在这里做了很多检查：首先，我们保证现在的时间戳和上一个时间戳之间的处以delay是有意义的。如果不是的话，我们就猜测着用上次的延迟。接着，我们有一个同步阈值，因为在同步的时候事情并不总是那么完美的。在ffplay中使用0.01作为它的值。我们也保证阈值不会比时间戳之间的间隔短。最后，我们把最小的刷新值设置为10毫秒。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>（这句不知道应该放在哪里）事实上这里我们应该跳过这一帧，但是我们不想为此而烦恼。</p>
</td>
</tr>
</tbody>
</table>
<p>我们给大结构体添加了很多的变量，所以不要忘记检查一下代码。同时也不要忘记在函数streame_component_open中初始化帧时间frame_timer和前面的帧延迟frame delay：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;frame_timer = (double)av_gettime() / 1000000.0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;frame_last_delay = 40e-3;</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;<wbr><wbr></p>
<p><strong>同步：声音时钟</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>现在让我们看一下怎样来得到声音时钟。我们可以在声音解码函数audio_decode_frame中更新时钟时间。现在，请记住我们并不是每次调用这个函数的时候都在处理新的包，所以有我们要在两个地方更新时钟。第一个地方是我们得到新的包的时候：我们简单的设置声音时钟为这个包的时间戳。然后，如果一个包里有许多帧，我们通过样本数和采样率来计算，所以当我们得到包的时候：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(pkt-&gt;pts != AV_NOPTS_VALUE) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
</td>
</tr>
</tbody>
</table>
<p>然后当我们处理这个包的时候：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pts = is-&gt;audio_clock;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> *pts_ptr = pts;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> n = 2 * is-&gt;audio_st-&gt;codec-&gt;channels;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;audio_clock += (double)data_size /</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> (double)(n * is-&gt;audio_st-&gt;codec-&gt;sample_rate);</p>
</td>
</tr>
</tbody>
</table>
<p>一点细节：临时函数被改成包含pts_ptr，所以要保证你已经改了那些。这时的pts_ptr是一个用来通知audio_callback函数当前声音包的时间戳的指针。这将在下次用来同步声音和视频。</p>
<p>现在我们可以最后来实现我们的get_audio_clock函数。它并不像得到is-&gt;audio_clock值那样简单。注意我们会在每次处理它的时候设置声音时间戳，但是如果你看了audio_callback函数，它花费了时间来把数据从声音包中移到我们的输出缓冲区中。这意味着我们声音时钟中记录的时间比实际的要早太多。所以我们必须要检查一下我们还有多少没有写入。下面是完整的代码：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>double get_audio_clock(VideoState *is) {</p>
<p>&nbsp;<wbr><wbr> double pts;</p>
<p>&nbsp;<wbr><wbr> int hw_buf_size, bytes_per_sec, n;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> pts = is-&gt;audio_clock;</p>
<p>&nbsp;<wbr><wbr> hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</p>
<p>&nbsp;<wbr><wbr> bytes_per_sec = 0;</p>
<p>&nbsp;<wbr><wbr> n = is-&gt;audio_st-&gt;codec-&gt;channels * 2;</p>
<p>&nbsp;<wbr><wbr> if(is-&gt;audio_st) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> bytes_per_sec = is-&gt;audio_st-&gt;codec-&gt;sample_rate * n;</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> if(bytes_per_sec) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pts -= (double)hw_buf_size / bytes_per_sec;</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> return pts;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>你应该知道为什么这个函数可以正常工作了;)</p>
<p>&nbsp;<wbr><wbr></p>
<p>这就是了！让我们编译它：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>gcc -o tutorial05 tutorial05.c -lavutil -lavformat -lavcodec -lz -lm`sdl-config --cflags --libs`</p>
</td>
</tr>
</tbody>
</table>
<p>最后，你可以使用我们自己的电影播放器来看电影了。下次我们将看一下声音同步，然后接下来的指导我们会讨论查询</p>
</div>
<p>&nbsp;<wbr><wbr></p>
</div>
<p><br>
</p>
<p>7<br>
</p>
<h2><a name="t6"></a>ffmpeg文档6</h2>
<span>(2008-08-27 18:44:22)</span>
<div><a><cite><img title="ffmpeg文档12345678" height="15" alt="ffmpeg文档12345678" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/sg_trans.gif" width="15" align="absMiddle">转载</cite></a></div>
<div>
<table>
<tbody>
<tr>
<td><span>标签：</span>
<h3><a name="t7"></a><a href="http://uni.sina.com.cn/c.php?t=blog&amp;k=%EF%BF%BD%EF%BF%BD%CC%B8&amp;ts=bpost&amp;stype=tag" target="_blank">杂谈</a></h3>
</td>
<td><span>分类：</span> <a href="http://blog.sina.com.cn/s/articlelist_1188849065_1_1.html" target="_blank">
翻译文档</a></td>
</tr>
</tbody>
</table>
</div>
<div>
<p align="center"><strong>指导6：同步音频</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>同步音频</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>现在我们已经有了一个比较像样的播放器。所以让我们看一下还有哪些零碎的东西没处理。上次，我们掩饰了一点同步问题，也就是同步音频到视频而不是其它的同步方式。我们将采用和视频一样的方式：做一个内部视频时钟来记录视频线程播放了多久，然后同步音频到上面去。后面我们也来看一下如何推而广之把音频和视频都同步到外部时钟。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>生成一个视频时钟</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>现在我们要生成一个类似于上次我们的声音时钟的视频时钟：一个给出当前视频播放时间的内部值。开始，你可能会想这和使用上一帧的时间戳来更新定时器一样简单。但是，不要忘了视频帧之间的时间间隔是很长的，以毫秒为计量的。解决办法是跟踪另外一个值：我们在设置上一帧时间戳的时候的时间值。于是当前视频时间值就是PTS_of_last_frame + (current_time - time_elapsed_since_PTS_value_was_set)。这种解决方式与我们在函数get_audio_clock中的方式很类似。</p>
<p>所在在我们的大结构体中，我们将放上一个双精度浮点变量video_current_pts和一个64位宽整型变量video_current_pts_time。时钟更新将被放在video_refresh_timer函数中。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>void video_refresh_timer(void *userdata) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> if(is-&gt;video_st) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(is-&gt;pictq_size == 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> schedule_refresh(is, 1);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;video_current_pts = vp-&gt;pts;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;video_current_pts_time = av_gettime();</p>
</td>
</tr>
</tbody>
</table>
<p>不要忘记在stream_component_open函数中初始化它：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;video_current_pts_time = av_gettime();</p>
</td>
</tr>
</tbody>
</table>
<p>现在我们需要一种得到信息的方式：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>double get_video_clock(VideoState *is) {</p>
<p>&nbsp;<wbr><wbr> double delta;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> delta = (av_gettime() - is-&gt;video_current_pts_time) / 1000000.0;</p>
<p>&nbsp;<wbr><wbr> return is-&gt;video_current_pts + delta;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;<wbr><wbr></p>
<p><strong>提取时钟</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>但是为什么要强制使用视频时钟呢？我们更改视频同步代码以致于音频和视频不会试着去相互同步。想像一下我们让它像ffplay一样有一个命令行参数。所以让我们抽象一样这件事情：我们将做一个新的封装函数get_master_clock，用来检测av_sync_type变量然后决定调用 get_audio_clock还是get_video_clock或者其它的想使用的获得时钟的函数。我们甚至可以使用电脑时钟，这个函数我们叫做 get_external_clock：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>enum {</p>
<p>&nbsp;<wbr><wbr> AV_SYNC_AUDIO_MASTER,</p>
<p>&nbsp;<wbr><wbr> AV_SYNC_VIDEO_MASTER,</p>
<p>&nbsp;<wbr><wbr> AV_SYNC_EXTERNAL_MASTER,</p>
<p>};</p>
<p>&nbsp;<wbr><wbr></p>
<p>#define DEFAULT_AV_SYNC_TYPE AV_SYNC_VIDEO_MASTER</p>
<p>&nbsp;<wbr><wbr></p>
<p>double get_master_clock(VideoState *is) {</p>
<p>&nbsp;<wbr><wbr> if(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> return get_video_clock(is);</p>
<p>&nbsp;<wbr><wbr> } else if(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> return get_audio_clock(is);</p>
<p>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> return get_external_clock(is);</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>}</p>
<p>main() {</p>
<p>...</p>
<p>&nbsp;<wbr><wbr> is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;</p>
<p>...</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;<wbr><wbr></p>
<p><strong>同步音频</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>现在是最难的部分：同步音频到视频时钟。我们的策略是测量声音的位置，把它与视频时间比较然后算出我们需要修正多少的样本数，也就是说：我们是否需要通过丢弃样本的方式来加速播放还是需要通过插值样本的方式来放慢播放？</p>
<p>我们将在每次处理声音样本的时候运行一个synchronize_audio的函数来正确的收缩或者扩展声音样本。然而，我们不想在每次发现有偏差的时候都进行同步，因为这样会使同步音频多于视频包。所以我们为函数synchronize_audio设置一个最小连续值来限定需要同步的时刻，这样我们就不会总是在调整了。当然，就像上次那样，“失去同步”意味着声音时钟和视频时钟的差异大于我们的阈值。</p>
<p>所以我们将使用一个分数系数，叫c，所以现在可以说我们得到了N个失去同步的声音样本。失去同步的数量可能会有很多变化，所以我们要计算一下失去同步的长度的均值。例如，第一次调用的时候，显示出来我们失去同步的长度为40ms，下次变为50ms等等。但是我们不会使用一个简单的均值，因为距离现在最近的值比靠前的值要重要的多。所以我们将使用一个分数系统，叫c，然后用这样的公式来计算差异：diff_sum = new_diff + diff_sum*c。当我们准备好去找平均差异的时候，我们用简单的计算方式：avg_diff
 = diff_sum * (1-c)。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>注意：为什么会在这里？这个公式看来很神奇！嗯，它基本上是一个使用等比级数的加权平均值。我不知道这是否有名字（我甚至查过维基百科！），但是如果想要更多的信息，这里是一个解释<a href="http://www.dranger.com/ffmpeg/weightedmean.html">http://www.dranger.com/ffmpeg/weightedmean.html</a>或者在<a href="http://www.dranger.com/ffmpeg/weightedmean.txt">http://www.dranger.com/ffmpeg/weightedmean.txt</a>里。</p>
</td>
</tr>
</tbody>
</table>
<p>下面是我们的函数：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr></p>
<p>int synchronize_audio(VideoState *is, short *samples,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> int samples_size, double pts) {</p>
<p>&nbsp;<wbr><wbr> int n;</p>
<p>&nbsp;<wbr><wbr> double ref_clock;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> n = 2 * is-&gt;audio_st-&gt;codec-&gt;channels;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> if(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> double diff, avg_diff;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> int wanted_size, min_size, max_size, nb_samples;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> ref_clock = get_master_clock(is);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> diff = get_audio_clock(is) - ref_clock;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(diff &lt; AV_NOSYNC_THRESHOLD) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // accumulate the diffs</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> * is-&gt;audio_diff_cum;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;audio_diff_avg_count++;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> avg_diff = is-&gt;audio_diff_cum * (1.0 - is-&gt;audio_diff_avg_coef);</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;audio_diff_avg_count = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;audio_diff_cum = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> return samples_size;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>现在我们已经做得很好；我们已经近似的知道如何用视频或者其它的时钟来调整音频了。所以让我们来计算一下要在添加和砍掉多少样本，并且如何在“Shrinking/expanding buffer code”部分来写上代码：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>if(fabs(avg_diff) &gt;= is-&gt;audio_diff_threshold) {</p>
<p>&nbsp;<wbr><wbr> wanted_size = samples_size +</p>
<p>&nbsp;<wbr><wbr> ((int)(diff * is-&gt;audio_st-&gt;codec-&gt;sample_rate) * n);</p>
<p>&nbsp;<wbr><wbr> min_size = samples_size * ((100 - SAMPLE_CORRECTION_PERCENT_MAX)</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>/
 100);</p>
<p>&nbsp;<wbr><wbr> max_size = samples_size * ((100 + SAMPLE_CORRECTION_PERCENT_MAX)</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>
 / 100);</p>
<p>&nbsp;<wbr><wbr> if(wanted_size &lt; min_size) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> wanted_size = min_size;</p>
<p>&nbsp;<wbr><wbr> } else if (wanted_size &gt; max_size) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> wanted_size = max_size;</p>
<p>&nbsp;<wbr><wbr> }</p>
</td>
</tr>
</tbody>
</table>
<p>记住audio_length * (sample_rate * # of channels * 2)就是audio_length秒时间的声音的样本数。所以，我们想要的样本数就是我们根据声音偏移添加或者减少后的声音样本数。我们也可以设置一个范围来限定我们一次进行修正的长度，因为如果我们改变的太多，用户会听到刺耳的声音。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>修正样本数</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>现在我们要真正的修正一下声音。你可能会注意到我们的同步函数synchronize_audio返回了一个样本数，这可以告诉我们有多少个字节被送到流中。所以我们只要调整样本数为wanted_size就可以了。这会让样本更小一些。但是如果我们想让它变大，我们不能只是让样本大小变大，因为在缓冲区中没有多余的数据！所以我们必需添加上去。但是我们怎样来添加呢？最笨的办法就是试着来推算声音，所以让我们用已有的数据在缓冲的末尾添加上最后的样本。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>if(wanted_size &lt; samples_size) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> samples_size = wanted_size;</p>
<p>} else if(wanted_size &gt; samples_size) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>uint8_t *samples_end, *q;</p>
<p>&nbsp;<wbr><wbr> int nb;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> nb = (samples_size - wanted_size);</p>
<p>&nbsp;<wbr><wbr> samples_end = (uint8_t *)samples + samples_size - n;</p>
<p>&nbsp;<wbr><wbr> q = samples_end + n;</p>
<p>&nbsp;<wbr><wbr> while(nb &gt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> memcpy(q, samples_end, n);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> q += n;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> nb -= n;</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> samples_size = wanted_size;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>现在我们通过这个函数返回的是样本数。我们现在要做的是使用它：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>void audio_callback(void *userdata, Uint8 *stream, int len) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> VideoState *is = (VideoState *)userdata;</p>
<p>&nbsp;<wbr><wbr> int len1, audio_size;</p>
<p>&nbsp;<wbr><wbr> double pts;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> while(len &gt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> audio_size = audio_decode_frame(is, is-&gt;audio_buf, sizeof(is-&gt;audio_buf), &amp;pts);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(audio_size &lt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;audio_buf_size = 1024;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> memset(is-&gt;audio_buf, 0, is-&gt;audio_buf_size);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> audio_size = synchronize_audio(is, (int16_t *)is-&gt;audio_buf,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> audio_size, pts);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;audio_buf_size = audio_size;</p>
</td>
</tr>
</tbody>
</table>
<p>我们要做的是把函数synchronize_audio插入进去。（同时，保证在初始化上面变量的时候检查一下代码，这些我没有赘述）。</p>
<p>结束之前的最后一件事情：我们需要添加一个if语句来保证我们不会在视频为主时钟的时候也来同步视频。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>if(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) {</p>
<p>&nbsp;<wbr><wbr> ref_clock = get_master_clock(is);</p>
<p>&nbsp;<wbr><wbr> diff = vp-&gt;pts - ref_clock;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay :</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> AV_SYNC_THRESHOLD;</p>
<p>&nbsp;<wbr><wbr> if(fabs(diff) &lt; AV_NOSYNC_THRESHOLD) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(diff &lt;= -sync_threshold) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> delay = 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> } else if(diff &gt;= sync_threshold) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> delay = 2 * delay;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>添加后就可以了。要保证整个程序中我没有赘述的变量都被初始化过了。然后编译它：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>gcc -o tutorial06 tutorial06.c -lavutil -lavformat -lavcodec -lz -lm`sdl-config --cflags --libs`</p>
</td>
</tr>
</tbody>
</table>
<p>然后你就可以运行它了。</p>
<p>下次我们要做的是让你可以让电影快退和快进。</p>
<p>--</p>
<h2><a name="t8"></a>ffmpeg文档7</h2>
<span>(2008-08-28 09:41:24)</span>
<div><a><cite><img title="ffmpeg文档12345678" height="15" alt="ffmpeg文档12345678" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/sg_trans.gif" width="15" align="absMiddle">转载</cite></a></div>
<div>
<table>
<tbody>
<tr>
<td><span>标签：</span>
<h3><a name="t9"></a><a href="http://uni.sina.com.cn/c.php?t=blog&amp;k=%EF%BF%BD%EF%BF%BD%CC%B8&amp;ts=bpost&amp;stype=tag" target="_blank">杂谈</a></h3>
</td>
<td><span>分类：</span> <a href="http://blog.sina.com.cn/s/articlelist_1188849065_1_1.html" target="_blank">
翻译文档</a></td>
</tr>
</tbody>
</table>
</div>
<div>
<p align="center"><strong>指导7：快进快退</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>处理快进快退命令</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>现在我们来为我们的播放器加入一些快进和快退的功能，因为如果你不能全局搜索一部电影是很让人讨厌的。同时，这将告诉你av_seek_frame函数是多么容易使用。</p>
<p>我们将在电影播放中使用左方向键和右方向键来表示向后和向前一小段，使用向上和向下键来表示向前和向后一大段。这里一小段是10秒，一大段是60秒。所以我们需要设置我们的主循环来捕捉键盘事件。然而当我们捕捉到键盘事件后我们不能直接调用av_seek_frame函数。我们要主要的解码线程 decode_thread的循环中做这些。所以，我们要添加一些变量到大结构体中，用来包含新的跳转位置和一些跳转标志：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr> int&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> seek_req;</p>
<p>&nbsp;<wbr><wbr> int&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> seek_flags;</p>
<p>&nbsp;<wbr><wbr> int64_t&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> seek_pos;</p>
</td>
</tr>
</tbody>
</table>
<p>现在让我们在主循环中捕捉按键：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr> for(;;) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> double incr, pos;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_WaitEvent(&amp;event);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> switch(event.type) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> case SDL_KEYDOWN:</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> switch(event.key.keysym.sym) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> case SDLK_LEFT:</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> incr = -10.0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> goto do_seek;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> case SDLK_RIGHT:</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> incr = 10.0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> goto do_seek;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> case SDLK_UP:</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> incr = 60.0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> goto do_seek;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> case SDLK_DOWN:</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> incr = -60.0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> goto do_seek;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> do_seek:</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(global_video_state) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr> pos = get_master_clock(global_video_state);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr> pos += incr;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> &nbsp;<wbr><wbr> stream_seek(global_video_state,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> (int64_t)(pos * AV_TIME_BASE),
 incr);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> default:</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> break;</p>
</td>
</tr>
</tbody>
</table>
<p>为了检测按键，我们先查了一下是否有SDL_KEYDOWN事件。然后我们使用event.key.keysym.sym来判断哪个按键被按下。一旦我们知道了如何来跳转，我们就来计算新的时间，方法为把增加的时间值加到从函数get_master_clock中得到的时间值上。然后我们调用 stream_seek函数来设置seek_pos等变量。我们把新的时间转换成为avcodec中的内部时间戳单位。在流中调用那个时间戳将使用帧而不是用秒来计算，公式为seconds = frames * time_base(fps)。默认的avcodec值为1,000,000fps（所以2秒的内部时间戳为2,000,000）。在后面我们来看一下为什么要把这个值进行一下转换。</p>
<p>这就是我们的stream_seek函数。请注意我们设置了一个标志为后退服务：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>void stream_seek(VideoState *is, int64_t pos, int rel) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> if(!is-&gt;seek_req) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;seek_pos = pos;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;seek_flags = rel &lt; 0 ? AVSEEK_FLAG_BACKWARD : 0;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;seek_req = 1;</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>现在让我们看一下如果在decode_thread中实现跳转。你会注意到我们已经在源文件中标记了一个叫做“seek stuff goes here”的部分。现在我们将把代码写在这里。</p>
<p>跳转是围绕着av_seek_frame函数的。这个函数用到了一个格式上下文，一个流，一个时间戳和一组标记来作为它的参数。这个函数将会跳转到你所给的时间戳的位置。时间戳的单位是你传递给函数的流的时基time_base。然而，你并不是必需要传给它一个流（流可以用-1来代替）。如果你这样做了，时基time_base将会是avcodec中的内部时间戳单位，或者是1000000fps。这就是为什么我们在设置seek_pos的时候会把位置乘以AV_TIME_BASER的原因。</p>
<p>但是，如果给av_seek_frame函数的stream参数传递传-1,你有时会在播放某些文件的时候遇到问题（比较少见），所以我们会取文件中的第一个流并且把它传递到av_seek_frame函数。不要忘记我们也要把时间戳timestamp的单位进行转化。</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>if(is-&gt;seek_req) {</p>
<p>&nbsp;<wbr><wbr> int stream_index= -1;</p>
<p>&nbsp;<wbr><wbr> int64_t seek_target = is-&gt;seek_pos;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> if&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> (is-&gt;videoStream &gt;= 0) stream_index = is-&gt;videoStream;</p>
<p>&nbsp;<wbr><wbr> else if(is-&gt;audioStream &gt;= 0) stream_index = is-&gt;audioStream;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> if(stream_index&gt;=0){</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> seek_target= av_rescale_q(seek_target, AV_TIME_BASE_Q,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pFormatCtx-&gt;streams[stream_index]-&gt;time_base);</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> if(av_seek_frame(is-&gt;pFormatCtx, stream_index,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> seek_target, is-&gt;seek_flags) &lt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> fprintf(stderr, "%s: error while seeking\n",</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;pFormatCtx-&gt;filename);</p>
<p>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
</td>
</tr>
</tbody>
</table>
<p>这里av_rescale_q(a,b,c)是用来把时间戳从一个时基调整到另外一个时基时候用的函数。它基本的动作是计算a*b/c，但是这个函数还是必需的，因为直接计算会有溢出的情况发生。AV_TIME_BASE_Q是AV_TIME_BASE作为分母后的版本。它们是很不相同的：AV_TIME_BASE * time_in_seconds = avcodec_timestamp而AV_TIME_BASE_Q * avcodec_timestamp = time_in_seconds（注意AV_TIME_BASE_Q实际上是一个AVRational对象，所以你必需使用avcodec中特定的q函数来处理它）。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>清空我们的缓冲</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>我们已经正确设定了跳转位置，但是我们还没有结束。记住我们有一个堆放了很多包的队列。既然我们跳到了不同的位置，我们必需把队列中的内容清空否则电影是不会跳转的。不仅如此，avcodec也有它自己的内部缓冲，也需要每次被清空。</p>
<p>要实现这个，我们需要首先写一个函数来清空我们的包队列。然后我们需要一种命令声音和视频线程来清空avcodec内部缓冲的办法。我们可以在清空队列后把特定的包放入到队列中，然后当它们检测到特定的包的时候，它们就会把自己的内部缓冲清空。</p>
<p>让我们开始写清空函数。其实很简单的，所以我直接把代码写在下面：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>static void packet_queue_flush(PacketQueue *q) {</p>
<p>&nbsp;<wbr><wbr> AVPacketList *pkt, *pkt1;</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> SDL_LockMutex(q-&gt;mutex);</p>
<p>&nbsp;<wbr><wbr> for(pkt = q-&gt;first_pkt; pkt != NULL; pkt = pkt1) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pkt1 = pkt-&gt;next;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> av_free_packet(&amp;pkt-&gt;pkt);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> av_freep(&amp;pkt);</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> q-&gt;last_pkt = NULL;</p>
<p>&nbsp;<wbr><wbr> q-&gt;first_pkt = NULL;</p>
<p>&nbsp;<wbr><wbr> q-&gt;nb_packets = 0;</p>
<p>&nbsp;<wbr><wbr> q-&gt;size = 0;</p>
<p>&nbsp;<wbr><wbr> SDL_UnlockMutex(q-&gt;mutex);</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>既然队列已经清空了，我们放入“清空包”。但是开始我们要定义和创建这个包：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>AVPacket flush_pkt;</p>
<p>&nbsp;<wbr><wbr></p>
<p>main() {</p>
<p>&nbsp;<wbr><wbr> ...</p>
<p>&nbsp;<wbr><wbr> av_init_packet(&amp;flush_pkt);</p>
<p>&nbsp;<wbr><wbr> flush_pkt.data = "FLUSH";</p>
<p>&nbsp;<wbr><wbr> ...</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>现在我们把这个包放到队列中：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr> } else {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(is-&gt;audioStream &gt;= 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> packet_queue_flush(&amp;is-&gt;audioq);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> packet_queue_put(&amp;is-&gt;audioq, &amp;flush_pkt);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(is-&gt;videoStream &gt;= 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> packet_queue_flush(&amp;is-&gt;videoq);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> packet_queue_put(&amp;is-&gt;videoq, &amp;flush_pkt);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr> is-&gt;seek_req = 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>（这些代码片段是接着前面decode_thread中的代码片段的）我们也需要修改packet_queue_put函数才不至于直接简单复制了这个包：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>int packet_queue_put(PacketQueue *q, AVPacket *pkt) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> AVPacketList *pkt1;</p>
<p>&nbsp;<wbr><wbr> if(pkt != &amp;flush_pkt &amp;&amp; av_dup_packet(pkt) &lt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> return -1;</p>
<p>&nbsp;<wbr><wbr> }</p>
</td>
</tr>
</tbody>
</table>
<p>然后在声音线程和视频线程中，我们在packet_queue_get后立即调用函数avcodec_flush_buffers：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(packet_queue_get(&amp;is-&gt;audioq, pkt, 1) &lt; 0) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> return -1;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(packet-&gt;data == flush_pkt.data) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> avcodec_flush_buffers(is-&gt;audio_st-&gt;codec);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> continue;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
</td>
</tr>
</tbody>
</table>
<p>上面的代码片段与视频线程中的一样，只要把“audio”换成“video”。</p>
<p>&nbsp;<wbr><wbr></p>
<p>就这样，让我们编译我们的播放器：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>gcc -o tutorial07 tutorial07.c -lavutil -lavformat -lavcodec -lz -lm`sdl-config --cflags --libs`</p>
</td>
</tr>
</tbody>
</table>
<p>试一下！我们几乎已经都做完了；下次我们只要做一点小的改动就好了，那就是检测ffmpeg提供的小的软件缩放采样。</p>
</div>
</div>
<p style="text-indent:24pt"><br>
</p>
<p style="text-indent:24pt"><br>
</p>
<div>
<h2><a name="t10"></a>［个人翻译］ffmpeg文档8</h2>
<span>(2008-08-28 09:43:45)</span>
<div><a><cite><img title="ffmpeg文档12345678" height="15" alt="ffmpeg文档12345678" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/sg_trans.gif" width="15" align="absMiddle">转载</cite></a></div>
</div>
<div>
<table>
<tbody>
<tr>
<td><span>标签：</span>
<h3><a name="t11"></a><a href="http://uni.sina.com.cn/c.php?t=blog&amp;k=%EF%BF%BD%EF%BF%BD%CC%B8&amp;ts=bpost&amp;stype=tag" target="_blank">杂谈</a></h3>
</td>
<td><span>分类：</span> <a href="http://blog.sina.com.cn/s/articlelist_1188849065_1_1.html" target="_blank">
翻译文档</a></td>
</tr>
</tbody>
</table>
</div>
<div>
<p align="center"><strong>指导8：软件缩放</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>软件缩放库libswscale</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>近来ffmpeg添加了新的接口：libswscale来处理图像缩放。</p>
<p>但是在前面我们使用img_convert来把RGB转换成YUV12，我们现在使用新的接口。新接口更加标准和快速，而且我相信里面有了MMX优化代码。换句话说，它是做缩放更好的方式。</p>
<p>我们将用来缩放的基本函数是sws_scale。但一开始，我们必需建立一个SwsContext的概念。这将让我们进行想要的转换，然后把它传递给 sws_scale函数。类似于在SQL中的预备阶段或者是在<a href="http://lib.csdn.net/base/python" class="replace_word" title="Python知识库" target="_blank" style="color:#df3434; font-weight:bold;">Python</a>中编译的规则表达式regexp。要准备这个上下文，我们使用 sws_getContext函数，它需要我们源的宽度和高度，我们想要的宽度和高度，源的格式和想要转换成的格式，同时还有一些其它的参数和标志。然后我们像使用img_convert一样来使用sws_scale函数，唯一不同的是我们传递给的是SwsContext：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>#include &lt;ffmpeg/swscale.h&gt; // include the header!</p>
<p>&nbsp;<wbr><wbr></p>
<p>int queue_picture(VideoState *is, AVFrame *pFrame, double pts) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> static struct SwsContext *img_convert_ctx;</p>
<p>&nbsp;<wbr><wbr> ...</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr> if(vp-&gt;bmp) {</p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> SDL_LockYUVOverlay(vp-&gt;bmp);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> dst_pix_fmt = PIX_FMT_YUV420P;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.data[0] = vp-&gt;bmp-&gt;pixels[0];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.data[1] = vp-&gt;bmp-&gt;pixels[2];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.data[2] = vp-&gt;bmp-&gt;pixels[1];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.linesize[0] = vp-&gt;bmp-&gt;pitches[0];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.linesize[1] = vp-&gt;bmp-&gt;pitches[2];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.linesize[2] = vp-&gt;bmp-&gt;pitches[1];</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr></p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> // Convert the image into YUV format that SDL uses</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(img_convert_ctx == NULL) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> int w = is-&gt;video_st-&gt;codec-&gt;width;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> int h = is-&gt;video_st-&gt;codec-&gt;height;</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> img_convert_ctx = sws_getContext(w, h,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>
 is-&gt;video_st-&gt;codec-&gt;pix_fmt,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>
 w, h, dst_pix_fmt, SWS_BICUBIC,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>
 NULL, NULL, NULL);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> if(img_convert_ctx == NULL) {</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> fprintf(stderr, "Cannot initialize the conversion context!\n");</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> exit(1);</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> }</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> sws_scale(img_convert_ctx, pFrame-&gt;data,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pFrame-&gt;linesize, 0,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> is-&gt;video_st-&gt;codec-&gt;height,</p>
<p>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr>&nbsp;<wbr><wbr> pict.data, pict.linesize);</p>
</td>
</tr>
</tbody>
</table>
<p>我们把新的缩放器放到了合适的位置。希望这会让你知道libswscale能做什么。</p>
<p>&nbsp;<wbr><wbr></p>
<p>就这样，我们做完了！编译我们的播放器：</p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="614">
<p>gcc -o tutorial08 tutorial08.c -lavutil -lavformat -lavcodec -lz -lm `sdl-config --cflags --libs`</p>
</td>
</tr>
</tbody>
</table>
<p>享受我们用C写的少于1000行的电影播放器吧。</p>
<p>当然，还有很多事情要做。</p>
<p>&nbsp;<wbr><wbr></p>
<p><strong>现在还要做什么？</strong></p>
<p>&nbsp;<wbr><wbr></p>
<p>我们已经有了一个可以工作的播放器，但是它肯定还不够好。我们做了很多，但是还有很多要添加的性能：</p>
<p>·错误处理。我们代码中的错误处理是无穷的，多处理一些会更好。</p>
<p>·暂停。我们不能暂停电影，这是一个很有用的功能。我们可以在大结构体中使用一个内部暂停变量，当用户暂停的时候就设置它。然后我们的音频，视频和解码线程检测到它后就不再输出任何东西。我们也使用av_read_play来支持网络。这很容易解释，但是你却不能明显的计算出，所以把这个作为一个家庭作业，如果你想尝试的话。提示，可以参考ffplay.c。</p>
<p>·支持视频硬件特性。一个参考的例子，请参考Frame Grabbing在Martin的旧的指导中的相关部分。<a href="http://www.inb.uni-luebeck.de/~boehme/libavcodec_update.html">http://www.inb.uni-luebeck.de/~boehme/libavcodec_update.html</a></p>
<p>·按字节跳转。如果你可以按照字节而不是秒的方式来计算出跳转位置，那么对于像VOB文件一样的有不连续时间戳的视频文件来说，定位会更加精确。</p>
<p>·丢弃帧。如果视频落后的太多，我们应当把下一帧丢弃掉而不是设置一个短的刷新时间。</p>
<p>·支持网络。现在的电影播放器还不能播放网络流媒体。</p>
<p>·支持像YUV文件一样的原始视频流。如果我们的播放器支持的话，因为我们不能猜测出时基和大小，我们应该加入一些参数来进行相应的设置。</p>
<p>·全屏。</p>
<p>·多种参数，例如：不同图像格式；参考ffplay.c中的命令开关。</p>
<p>·其它事情，例如：在结构体中的音频缓冲区应该对齐。</p>
<p>&nbsp;<wbr><wbr></p>
</div>
<p style="text-indent:24pt"><br>
</p>
<p style="text-indent:24pt"><br>
</p>
<div class="clearit"></div>
<div class="SG_connFoot"></div>
<div class="SG_colWnone" id="column_3">
<div style="margin:0px; width:0px; height:0px">&nbsp;&nbsp;</div>
</div>
   
</div>




<!-- Baidu Button BEGIN -->




<div class="bdsharebuttonbox tracking-ad bdshare-button-style0-16" style="float: right;" data-mod="popu_172" data-bd-bind="1486385432486">
<a href="http://blog.csdn.net/cffishappy/article/details/7352898#" class="bds_more" data-cmd="more" style="background-position:0 0 !important; background-image: url(http://bdimg.share.baidu.com/static/api/img/share/icons_0_16.png?v=d754dcc0.png) !important" target="_blank"></a>
<a href="http://blog.csdn.net/cffishappy/article/details/7352898#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间" style="background-position:0 -52px !important" target="_blank"></a>
<a href="http://blog.csdn.net/cffishappy/article/details/7352898#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博" style="background-position:0 -104px !important" target="_blank"></a>
<a href="http://blog.csdn.net/cffishappy/article/details/7352898#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博" style="background-position:0 -260px !important" target="_blank"></a>
<a href="http://blog.csdn.net/cffishappy/article/details/7352898#" class="bds_renren" data-cmd="renren" title="分享到人人网" style="background-position:0 -208px !important" target="_blank"></a>
<a href="http://blog.csdn.net/cffishappy/article/details/7352898#" class="bds_weixin" data-cmd="weixin" title="分享到微信" style="background-position:0 -1612px !important" target="_blank"></a>
</div>
<script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];</script>
<!-- Baidu Button END -->

   <link rel="stylesheet" href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/blog_detail.css">

    
<!--172.16.140.11-->

<!-- Baidu Button BEGIN -->
<script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=1536434" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/bds_s_v2.js.下载"></script>

<script type="text/javascript">
    document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)
</script>
<!-- Baidu Button END -->

 


        <div id="digg" articleid="7352898">
            <dl id="btnDigg" class="digg digg_enable" onclick="btndigga();">
               
                 <dt>顶</dt>
                <dd>2</dd>
            </dl>
           
              
            <dl id="btnBury" class="digg digg_enable" onclick="btnburya();">
              
                  <dt>踩</dt>
                <dd>0</dd>               
            </dl>
            
        </div>
     <div class="tracking-ad" data-mod="popu_222"><a href="javascript:void(0);" target="_blank">&nbsp;</a>   </div>
    <div class="tracking-ad" data-mod="popu_223"> <a href="javascript:void(0);" target="_blank">&nbsp;</a></div>
    <script type="text/javascript">
                function btndigga() {
                    $(".tracking-ad[data-mod='popu_222'] a").click();
                }
                function btnburya() {
                    $(".tracking-ad[data-mod='popu_223'] a").click();
                }
            </script>

   <ul class="article_next_prev">
                <li class="prev_article"><span onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_shangyipian&#39;]);location.href=&#39;/cffishappy/article/details/7343510&#39;;">上一篇</span><a href="http://blog.csdn.net/cffishappy/article/details/7343510" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_shangyipian&#39;])">十三种时间管理方法</a></li>
                <li class="next_article"><span onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_xiayipian&#39;]);location.href=&#39;/cffishappy/article/details/7353816&#39;;">下一篇</span><a href="http://blog.csdn.net/cffishappy/article/details/7353816" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_xiayipian&#39;])">fatal error C1189: #error :  WINDOWS.H already included.  MFC apps must not #include &lt;windows.h&gt;</a></li>
    </ul>

    <div style="clear:both; height:10px;"></div>


        <div class="similar_article" style="">
                <h4>我的同类文章</h4>
                <div class="similar_c" style="margin:20px 0px 0px 0px">
                    <div class="similar_c_t">
                                <label class="similar_cur">
                                    <span style="cursor:pointer" onclick="GetCategoryArticles(&#39;883975&#39;,&#39;cffishappy&#39;,&#39;foot&#39;,&#39;7352898&#39;);">流媒体<em>（47）</em></span>
                                </label>
                    </div>
                   
                    <div class="similar_wrap tracking-ad" data-mod="popu_141" style="max-height:195px;">
                        <a href="http://blog.csdn.net/" style="display:none" target="_blank">http://blog.csdn.net</a>
                        <ul class="similar_list fl"><li><em>•</em><a href="http://blog.csdn.net/cffishappy/article/details/51671684" id="foot_aritcle_51671684undefined125750590909544" target="_blank" title="SDL_CreateRenderer(screen, -1, 0)在xp中崩溃">SDL_CreateRenderer(screen, -1, 0)在xp中崩溃</a><span>2016-06-14</span><label><i>阅读</i><b>282</b></label></li> <li><em>•</em><a href="http://blog.csdn.net/cffishappy/article/details/50971551" id="foot_aritcle_50971551undefined21092194607817127" target="_blank" title="AVPacket  &amp;&amp; av_read_frame 会导致内存泄漏">AVPacket  &amp;&amp; av_read_frame 会导致内存泄漏</a><span>2016-03-24</span><label><i>阅读</i><b>893</b></label></li> <li><em>•</em><a href="http://blog.csdn.net/cffishappy/article/details/8452214" id="foot_aritcle_8452214undefined7796929574591602" target="_blank" title="live_media_代码阅读笔记">live_media_代码阅读笔记</a><span>2012-12-30</span><label><i>阅读</i><b>465</b></label></li> <li><em>•</em><a href="http://blog.csdn.net/cffishappy/article/details/8448501" id="foot_aritcle_8448501undefined46484473826725714" target="_blank" title="live555学习4（转）">live555学习4（转）</a><span>2012-12-28</span><label><i>阅读</i><b>1470</b></label></li> <li><em>•</em><a href="http://blog.csdn.net/cffishappy/article/details/7717724" id="foot_aritcle_7717724undefined8968979644393114" target="_blank" title="undefined reference to `img_convert’的解决方法">undefined reference to `img_convert’的解决方法</a><span>2012-07-05</span><label><i>阅读</i><b>1835</b></label></li> <li><em>•</em><a href="http://blog.csdn.net/cffishappy/article/details/7677957" id="foot_aritcle_7677957undefined8844714875594724" target="_blank" title="AVI文件格式解析2">AVI文件格式解析2</a><span>2012-06-19</span><label><i>阅读</i><b>2545</b></label></li> </ul>

                        <ul class="similar_list fr"><li><em>•</em><a href="http://blog.csdn.net/cffishappy/article/details/51083801" id="foot_aritcle_51083801undefined859761331427588" target="_blank" title="Directshow获取系统默认设备">Directshow获取系统默认设备</a><span>2016-04-07</span><label><i>阅读</i><b>288</b></label></li> <li><em>•</em><a href="http://blog.csdn.net/cffishappy/article/details/12955749" id="foot_aritcle_12955749undefined42894982929483194" target="_blank" title="wireshark Lua">wireshark Lua</a><span>2013-10-22</span><label><i>阅读</i><b>1144</b></label></li> <li><em>•</em><a href="http://blog.csdn.net/cffishappy/article/details/8448756" id="foot_aritcle_8448756undefined44548944690256187" target="_blank" title="live555学习3（转）">live555学习3（转）</a><span>2012-12-28</span><label><i>阅读</i><b>910</b></label></li> <li><em>•</em><a href="http://blog.csdn.net/cffishappy/article/details/8448448" id="foot_aritcle_8448448undefined1693199704354038" target="_blank" title="live555学习1（转）">live555学习1（转）</a><span>2012-12-28</span><label><i>阅读</i><b>2073</b></label></li> <li><em>•</em><a href="http://blog.csdn.net/cffishappy/article/details/7680097" id="foot_aritcle_7680097undefined16180188469140155" target="_blank" title="broken ffmpeg default settings detected&quot; and &quot;use an encoding preset (vpre)&quot;">broken ffmpeg default settings detected" and "use an encoding preset (vpre)"</a><span>2012-06-20</span><label><i>阅读</i><b>4589</b></label></li> </ul>
                    <a href="http://blog.csdn.net/cffishappy/article/category/883975" class="MoreArticle">更多文章</a></div>
                </div>
            </div>    
    <script type="text/javascript">
        $(function () {
            GetCategoryArticles('883975', 'cffishappy','foot','7352898');
        });
    </script>
      
</div>

    <div>
            <script type="text/javascript">
                /*博客内容页下方Banner1-728*90，创建于2016-12-13*/
                var cpro_id = "u2843949";
            </script>
            <script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/c.js.下载"></script><div id="BAIDU_SSP__wrapper_u2843949_0"><iframe id="iframeu2843949_0" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/ccom.html" width="728" height="90" align="center,center" vspace="0" hspace="0" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" style="border:0; vertical-align:bottom;margin:0;" allowtransparency="true"></iframe></div>
     </div>

<div id="suggest">

</div>
         <script language="javascript" type="text/javascript">     
             $(function(){
                 $.get("/cffishappy/svc/GetSuggestContent/7352898",function(data){
                     $("#suggest").html(data);
                 });     
             });             
         </script>  


<style>
.blog-ass-articl dd {
color: #369;
width: 99%; /*修改行*/
float: left;
overflow: hidden;
font: normal normal 12px/23px "SimSun";
height: 23px;
margin: 0;
padding: 0 0 0 10px;
margin-right: 30px;
background: url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;
}
</style>

 <link rel="stylesheet" href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/replace.css">

<div id="relate" data-mod="popu_218" class="tracking-ad" style="display: block;">
        <div class="relate_t">
            <h3><span>参考知识库</span></h3>
        </div>
        <div class="relate_c"><dl class="relate_list"><dt><a target="_blank" href="http://lib.csdn.net/base/python"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/1452500783406_406.jpg" alt="img"></a></dt><dd><h4><a target="_blank" href="http://lib.csdn.net/base/python">Python知识库</a></h4><p><label><span>18698</span><em>关注</em><i>|</i><span>1269</span><em>收录</em></label></p></dd></dl><dl class="relate_list"><dt><a target="_blank" href="http://lib.csdn.net/base/linux"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/1468390230134_134.jpg" alt="img"></a></dt><dd><h4><a target="_blank" href="http://lib.csdn.net/base/linux">Linux知识库</a></h4><p><label><span>9441</span><em>关注</em><i>|</i><span>3538</span><em>收录</em></label></p></dd></dl><dl class="relate_list"><dt><a target="_blank" href="http://lib.csdn.net/base/operatingsystem"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/1464938192555_555.jpg" alt="img"></a></dt><dd><h4><a target="_blank" href="http://lib.csdn.net/base/operatingsystem">操作系统知识库</a></h4><p><label><span>4888</span><em>关注</em><i>|</i><span>2210</span><em>收录</em></label></p></dd></dl><dl class="relate_list"><dt><a target="_blank" href="http://lib.csdn.net/base/docker"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/1452500466484_484.jpg" alt="img"></a></dt><dd><h4><a target="_blank" href="http://lib.csdn.net/base/docker">Docker知识库</a></h4><p><label><span>5746</span><em>关注</em><i>|</i><span>237</span><em>收录</em></label></p></dd></dl><dl class="relate_list"><dt><a target="_blank" href="http://lib.csdn.net/base/softwaretest"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/1467193268346_346.jpg" alt="img"></a></dt><dd><h4><a target="_blank" href="http://lib.csdn.net/base/softwaretest">软件测试知识库</a></h4><p><label><span>3437</span><em>关注</em><i>|</i><span>310</span><em>收录</em></label></p></dd></dl></div>
</div>
 

<dl class="blog-ass-articl" id="res-relatived"> 
    <div class="embody embody_b" id="libkeyparent" style="display:none">
            <span class="embody_t">更多资料请参考：</span>
            <div class="embody_c" id="libkey"></div>
    </div>


     <dt><span>猜你在找</span></dt>    


   


    <div id="adCollege" style="width: 42%;float: left;"> 
        <script src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/job_reco.js.下载" type="text/javascript"></script> 
        <script type="text/javascript">
            csdn.position.showEdu({
                sourceType: "blog",
                searchType: "detail",
                searchKey: "7352898",
                username: "qq_21102585",
                recordcount: "5",
                containerId: "adCollege" //容器DIV的id。 
            });
        </script> 
    <div class="tracking-ad" data-mod="popu_84"><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px; white-space: nowrap;"><a href="http://edu.csdn.net/course/detail/3137" title="Oracle数据库开发之PL/SQL基础实战视频课程" strategy="v4:content" target="_blank">Oracle数据库开发之PL/SQL基础实战视频课程</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px; white-space: nowrap;"><a href="http://edu.csdn.net/course/detail/3708" title="从零开始学习mac系统视频录制编辑软件Camtasia For Mac视频课程" strategy="v4:content" target="_blank">从零开始学习mac系统视频录制编辑软件Camtasia For Mac视频课程</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px; white-space: nowrap;"><a href="http://edu.csdn.net/course/detail/2315" title="屏幕录像软件oCam入门实战视频课程" strategy="v4:content" target="_blank">屏幕录像软件oCam入门实战视频课程</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px; white-space: nowrap;"><a href="http://edu.csdn.net/course/detail/1956" title="Excel数据透视表实战视频课程【你学得会】" strategy="v4:content" target="_blank">Excel数据透视表实战视频课程【你学得会】</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px; white-space: nowrap;"><a href="http://edu.csdn.net/course/detail/3284" title="iOS9高级程序设计（顶级iOS开发视频课程-Objective-C版）" strategy="v4:content" target="_blank">iOS9高级程序设计（顶级iOS开发视频课程-Objective-C版）</a></dd></div></div>  

    
     <div id="res" data-mod="popu_36" class="tracking-ad" style="width: 42%; float: left; margin-right: 30px; display: block;"><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/BrookIcv/article/details/52590775" title="FFmpeg学习5多线程播放视音频" strategy="SearchAlgorithm" target="_blank">FFmpeg学习5多线程播放视音频</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/key123zhangxing/article/details/39672085" title="ffmpeg+sdl音频播放器" strategy="SearchAlgorithm" target="_blank">ffmpeg+sdl音频播放器</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/lgh1992314/article/details/52128119" title="最简单的基于FFMPEG+SDL的视频播放器拆分-解码器和播放器" strategy="SearchAlgorithm" target="_blank">最简单的基于FFMPEG+SDL的视频播放器拆分-解码器和播放器</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/leixiaohua1020/article/details/46889389" title="最简单的基于FFMPEG+SDL的视频播放器拆分-解码器和播放器" strategy="SearchAlgorithm" target="_blank">最简单的基于FFMPEG+SDL的视频播放器拆分-解码器和播放器</a></dd><dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="http://blog.csdn.net/ww506772362/article/details/49865403" title="英特尔 QSV 在 FFMPEG 中的使用Windows" strategy="SearchAlgorithm" target="_blank">英特尔 QSV 在 FFMPEG 中的使用Windows</a></dd></div>
   
</dl>


<script type="text/javascript">
    $(function () {
        setTimeout(function () {
            var searchtitletags = 'ffmpeg教程' + ',' + $("#tags").html();
            searchService({
                index: 'blog',
                query: searchtitletags,
                from: 5,
                size: 5,
                appendTo: '#res',
                url: 'recommend',
                his: 2,
                client: "blog_cf_enhance",
                tmpl: '<dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="#{ url }" title="#{ title }" strategy="#{ strategy }">#{ title }</a></dd>'
            });
        }, 500);
    });    

 </script>  


    <div id="ad_cen">        
                    <script type="text/javascript">
                        /*博客内容页下方Banner-728*90，创建于2014-7-3*/
                        var cpro_id = "u1607657";
                    </script>
                    <script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/c.js.下载"></script><div id="BAIDU_SSP__wrapper_u1607657_0"><iframe id="iframeu1607657_0" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/ccom(1).html" width="728" height="90" align="center,center" vspace="0" hspace="0" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" style="border:0; vertical-align:bottom;margin:0;" allowtransparency="true"></iframe></div>
    </div>  


<div class="comment_class">
    <div id="comment_title" class="panel_head">
        <span class="see_comment">查看评论</span><a name="comments"></a></div>
    <div id="comment_list"><dl class="comment_item comment_topic" id="comment_item_4155471"><dt class="comment_head" floor="9">9楼 <span class="user"><a class="username" href="http://blog.csdn.net/bojie5744" target="_blank">phypor</a> <span class="ptime">2014-08-09 12:22发表</span>  <a href="http://blog.csdn.net/cffishappy/article/details/7352898#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4155471" username="bojie5744"> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/bojie5744" target="_blank"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/3_bojie5744.jpg" width="40" height="40"></a></dd><dd class="comment_body">很好。</dd></dl><dl class="comment_item comment_topic" id="comment_item_4053295"><dt class="comment_head" floor="8">8楼 <span class="user"><a class="username" href="http://blog.csdn.net/sunny1773" target="_blank">sunny1773</a> <span class="ptime">2014-07-16 11:09发表</span>  <a href="http://blog.csdn.net/cffishappy/article/details/7352898#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="4053295" username="sunny1773"> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/sunny1773" target="_blank"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/3_sunny1773.jpg" width="40" height="40"></a></dd><dd class="comment_body">楼主您好，请问一下函数<br>avformat_open_input(AVFormatContext **ps, <br>const char *filename, <br>AVInputFormat *fmt, <br>AVDictionary **options)<br>里面，第三个参数如果我要定义一个具体的格式，如H264，那这个参数应该如何定义？</dd></dl><dl class="comment_item comment_topic" id="comment_item_3836167"><dt class="comment_head" floor="7">7楼 <span class="user"><a class="username" href="http://blog.csdn.net/peizhiluo" target="_blank">peizhiluo</a> <span class="ptime">2014-05-13 14:59发表</span>  <a href="http://blog.csdn.net/cffishappy/article/details/7352898#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3836167" username="peizhiluo"> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/peizhiluo" target="_blank"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/3_peizhiluo.jpg" width="40" height="40"></a></dd><dd class="comment_body">非常不错，受益匪浅。</dd></dl><dl class="comment_item comment_topic" id="comment_item_3612331"><dt class="comment_head" floor="6">6楼 <span class="user"><a class="username" href="http://blog.csdn.net/Jinliang_890905" target="_blank">小金的CSDN博客</a> <span class="ptime">2014-03-19 22:06发表</span>  <a href="http://blog.csdn.net/cffishappy/article/details/7352898#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3612331" username="Jinliang_890905"> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/Jinliang_890905" target="_blank"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/3_jinliang_890905.jpg" width="40" height="40"></a></dd><dd class="comment_body">mark</dd></dl><dl class="comment_item comment_topic" id="comment_item_3389179"><dt class="comment_head" floor="5">5楼 <span class="user"><a class="username" href="http://blog.csdn.net/wjc19911118" target="_blank">coder_up</a> <span class="ptime">2014-01-10 15:47发表</span>  <a href="http://blog.csdn.net/cffishappy/article/details/7352898#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="3389179" username="wjc19911118"> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/wjc19911118" target="_blank"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/3_wjc19911118.jpg" width="40" height="40"></a></dd><dd class="comment_body">楼主问你个问题：我现在有两个视频流包含音频，我现在合并只能有一个声音，另一个声音合不进去，你知道怎么弄吗？</dd></dl><dl class="comment_item comment_topic" id="comment_item_2973351"><dt class="comment_head" floor="4">4楼 <span class="user"><a class="username" href="http://blog.csdn.net/jhybb" target="_blank">jhybb</a> <span class="ptime">2013-10-11 14:13发表</span>  <a href="http://blog.csdn.net/cffishappy/article/details/7352898#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2973351" username="jhybb"> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/jhybb" target="_blank"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/3_jhybb.jpg" width="40" height="40"></a></dd><dd class="comment_body">代码看不懂 不过耐心看完后 还是有所收获</dd></dl><dl class="comment_item comment_topic" id="comment_item_2949709"><dt class="comment_head" floor="3">3楼 <span class="user"><a class="username" href="http://blog.csdn.net/dgyanyong" target="_blank">特招</a> <span class="ptime">2013-09-29 11:35发表</span>  <a href="http://blog.csdn.net/cffishappy/article/details/7352898#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2949709" username="dgyanyong"> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/dgyanyong" target="_blank"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/3_dgyanyong.jpg" width="40" height="40"></a></dd><dd class="comment_body">顶一个。非常感谢。</dd></dl><dl class="comment_item comment_topic" id="comment_item_2559342"><dt class="comment_head" floor="2">2楼 <span class="user"><a class="username" href="http://blog.csdn.net/zhanggeng0205" target="_blank">zhanggeng0205</a> <span class="ptime">2013-03-19 17:03发表</span>  <a href="http://blog.csdn.net/cffishappy/article/details/7352898#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2559342" username="zhanggeng0205"> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/zhanggeng0205" target="_blank"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/3_zhanggeng0205.jpg" width="40" height="40"></a></dd><dd class="comment_body">荡漾</dd></dl><dl class="comment_item comment_topic" id="comment_item_2476920"><dt class="comment_head" floor="1">1楼 <span class="user"><a class="username" href="http://blog.csdn.net/sxpqi" target="_blank">sxpqi</a> <span class="ptime">2012-12-21 10:58发表</span>  <a href="http://blog.csdn.net/cffishappy/article/details/7352898#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="2476920" username="sxpqi"> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="http://blog.csdn.net/cffishappy/article/details/7352898#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/sxpqi" target="_blank"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/3_sxpqi.jpg" width="40" height="40"></a></dd><dd class="comment_body">搂住真是尽心尽力</dd></dl><div class="clear"></div></div>
    <div id="comment_bar" style="display: none;">
    </div>
    <div id="comment_form"><a name="commentbox"></a><a name="reply"></a><a name="quote"></a><form action="http://blog.csdn.net/cffishappy/comment/submit?id=7352898" method="post" onsubmit="return subform(this);"><div class="commentform"><div class="panel_head">发表评论</div><ul><li class="left">用 户 名：</li><li class="right">qq_21102585</li></ul><ul><li class="left">评论内容：</li><li class="right" style="position:relative;"><div id="ubbtools"><a href="http://blog.csdn.net/cffishappy/article/details/7352898#insertcode" code="code"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/code.gif" border="0" alt="插入代码" title="插入代码"></a></div><div id="lang_list" style="position: absolute; top: 28px; left: 0px; display: none;"><a class="long_name" href="http://blog.csdn.net/cffishappy/article/details/7352898#html">HTML/XML</a><a class="long_name" href="http://blog.csdn.net/cffishappy/article/details/7352898#objc">objective-c</a><a class="zhong_name" href="http://blog.csdn.net/cffishappy/article/details/7352898#delphi">Delphi</a><a class="zhong_name" href="http://blog.csdn.net/cffishappy/article/details/7352898#ruby">Ruby</a><a href="http://blog.csdn.net/cffishappy/article/details/7352898#php">PHP</a><a class="duan_name" href="http://blog.csdn.net/cffishappy/article/details/7352898#csharp">C#</a><a style=" border-right: none;" class="duan_name" href="http://blog.csdn.net/cffishappy/article/details/7352898#cpp">C++</a><a style=" border-bottom:none;" class="long_name" href="http://blog.csdn.net/cffishappy/article/details/7352898#javascript">JavaScript</a><a style=" border-bottom:none;" class="long_name" href="http://blog.csdn.net/cffishappy/article/details/7352898#vb">Visual Basic</a><a style=" border-bottom:none;" class="zhong_name" href="http://blog.csdn.net/cffishappy/article/details/7352898#python">Python</a><a style=" border-bottom:none;" class="zhong_name" href="http://blog.csdn.net/cffishappy/article/details/7352898#java">Java</a><a style="border-bottom:none;" class="duan_name" href="http://blog.csdn.net/cffishappy/article/details/7352898#css">CSS</a><a style="border-bottom:none;" class="duan_name" href="http://blog.csdn.net/cffishappy/article/details/7352898#sql">SQL</a><a style="border:none;" class="duan_name" href="http://blog.csdn.net/cffishappy/article/details/7352898#plain">其它</a></div><textarea class="comment_content" name="comment_content" id="comment_content" style="width: 400px; height: 200px;"></textarea></li></ul><ul><input type="hidden" id="comment_replyId" name="comment_replyId"><input type="hidden" id="comment_userId" name="comment_userId" value="521203"><input type="hidden" id="commentId" name="commentId" value=""><input type="submit" class="comment_btn" value="提交">&nbsp;&nbsp;<span id="tip_comment" style="color: Red; display: none;"></span></ul></div></form></div>
    <div class="announce">
        * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场<a name="reply"></a><a name="quote"></a></div>
</div>

<script type="text/javascript">
    var fileName = '7352898';
    var commentscount = 9;
    var islock = false
</script>
<script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/comment.js.下载"></script>
    <div id="ad_bot">
    </div>
<div id="report_dialog">
</div>

<div id="d-top" style="bottom:60px;">

        <a id="quick-reply" class="btn btn-top q-reply" title="快速回复" style="display:none;">
            <img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/blog-icon-reply.png" alt="快速回复">
        </a>    
    <a id="d-top-a" class="btn btn-top backtop" style="display: none;" title="返回顶部" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_huidaodingbu&#39;])">         
         <img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/top.png" alt="TOP">
    </a>
</div>
<script type="text/javascript">
    $(function ()
    {
        $("#ad_frm_0").height("90px");
        
        setTimeout(function(){
            $("#ad_frm_2").height("200px");
        },1000);    
    });
  
</script>
<style type="text/css">
    .tag_list
    {
        background: none repeat scroll 0 0 #FFFFFF;
        border: 1px solid #D7CBC1;
        color: #000000;
        font-size: 12px;
        line-height: 20px;
        list-style: none outside none;
        margin: 10px 2% 0 1%;
        padding: 1px;
    }
    .tag_list h5
    {
        background: none repeat scroll 0 0 #E0DBD3;
        color: #47381C;
        font-size: 12px;
        height: 24px;
        line-height: 24px;
        padding: 0 5px;
        margin: 0;
    }
    .tag_list h5 a
    {
        color: #47381C;
    }
    .classify
    {
        margin: 10px 0;
        padding: 4px 12px 8px;
    }
    .classify a
    {
        margin-right: 20px;
        white-space: nowrap;
    }
</style>


<div class="tag_list" style="">

    <h5>
        <a href="http://www.csdn.net/tag/" target="_blank">核心技术类目</a></h5>
    <div class="classify">
<a title="全部主题" href="http://www.csdn.net/tag" target="_blank" onclick="LogClickCount(this,336);">全部主题</a>
<a title="Hadoop" href="http://g.csdn.net/5272865" target="_blank" onclick="LogClickCount(this,336);">Hadoop</a>
<a title="AWS" href="http://g.csdn.net/5272866" target="_blank" onclick="LogClickCount(this,336);">AWS</a>
<a title="移动游戏" href="http://g.csdn.net/5272870" target="_blank" onclick="LogClickCount(this,336);">移动游戏</a>
<a title="Java" href="http://g.csdn.net/5272871" target="_blank" onclick="LogClickCount(this,336);">Java</a>
<a title="Android" href="http://g.csdn.net/5272872" target="_blank" onclick="LogClickCount(this,336);">Android</a>
<a title="iOS" href="http://g.csdn.net/5272873" target="_blank" onclick="LogClickCount(this,336);">iOS</a>
<a title="Swift" href="http://g.csdn.net/5272868" target="_blank" onclick="LogClickCount(this,336);">Swift</a>
<a title="智能硬件" href="http://g.csdn.net/5272869" target="_blank" onclick="LogClickCount(this,336);">智能硬件</a>
<a title="Docker" href="http://g.csdn.net/5272867" target="_blank" onclick="LogClickCount(this,336);">Docker</a>
<a title="OpenStack" href="http://g.csdn.net/5272925" target="_blank" onclick="LogClickCount(this,336);">OpenStack</a>
<a title="VPN" href="http://www.csdn.net/tag/vpn" target="_blank" onclick="LogClickCount(this,336);">VPN</a>
<a title="Spark" href="http://g.csdn.net/5272924" target="_blank" onclick="LogClickCount(this,336);">Spark</a>
<a title="ERP" href="http://www.csdn.net/tag/erp" target="_blank" onclick="LogClickCount(this,336);">ERP</a>
<a title="IE10" href="http://www.csdn.net/tag/ie10" target="_blank" onclick="LogClickCount(this,336);">IE10</a>
<a title="Eclipse" href="http://www.csdn.net/tag/eclipse" target="_blank" onclick="LogClickCount(this,336);">Eclipse</a>
<a title="CRM" href="http://www.csdn.net/tag/crm" target="_blank" onclick="LogClickCount(this,336);">CRM</a>
<a title="JavaScript" href="http://www.csdn.net/tag/javascript" target="_blank" onclick="LogClickCount(this,336);">JavaScript</a>
<a title="数据库" href="http://www.csdn.net/tag/%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" onclick="LogClickCount(this,336);">数据库</a>
<a title="Ubuntu" href="http://www.csdn.net/tag/ubuntu" target="_blank" onclick="LogClickCount(this,336);">Ubuntu</a>
<a title="NFC" href="http://www.csdn.net/tag/nfc" target="_blank" onclick="LogClickCount(this,336);">NFC</a>
<a title="WAP" href="http://www.csdn.net/tag/wap" target="_blank" onclick="LogClickCount(this,336);">WAP</a>
<a title="jQuery" href="http://www.csdn.net/tag/jquery" target="_blank" onclick="LogClickCount(this,336);">jQuery</a>
<a title="BI" href="http://www.csdn.net/tag/bi" target="_blank" onclick="LogClickCount(this,336);">BI</a>
<a title="HTML5" href="http://www.csdn.net/tag/html5" target="_blank" onclick="LogClickCount(this,336);">HTML5</a>
<a title="Spring" href="http://www.csdn.net/tag/spring" target="_blank" onclick="LogClickCount(this,336);">Spring</a>
<a title="Apache" href="http://www.csdn.net/tag/apache" target="_blank" onclick="LogClickCount(this,336);">Apache</a>
<a title=".NET" href="http://www.csdn.net/tag/.net" target="_blank" onclick="LogClickCount(this,336);">.NET</a>
<a title="API" href="http://www.csdn.net/tag/api" target="_blank" onclick="LogClickCount(this,336);">API</a>
<a title="HTML" href="http://www.csdn.net/tag/html" target="_blank" onclick="LogClickCount(this,336);">HTML</a>
<a title="SDK" href="http://www.csdn.net/tag/sdk" target="_blank" onclick="LogClickCount(this,336);">SDK</a>
<a title="IIS" href="http://www.csdn.net/tag/iis" target="_blank" onclick="LogClickCount(this,336);">IIS</a>
<a title="Fedora" href="http://www.csdn.net/tag/fedora" target="_blank" onclick="LogClickCount(this,336);">Fedora</a>
<a title="XML" href="http://www.csdn.net/tag/xml" target="_blank" onclick="LogClickCount(this,336);">XML</a>
<a title="LBS" href="http://www.csdn.net/tag/lbs" target="_blank" onclick="LogClickCount(this,336);">LBS</a>
<a title="Unity" href="http://www.csdn.net/tag/unity" target="_blank" onclick="LogClickCount(this,336);">Unity</a>
<a title="Splashtop" href="http://www.csdn.net/tag/splashtop" target="_blank" onclick="LogClickCount(this,336);">Splashtop</a>
<a title="UML" href="http://www.csdn.net/tag/uml" target="_blank" onclick="LogClickCount(this,336);">UML</a>
<a title="components" href="http://www.csdn.net/tag/components" target="_blank" onclick="LogClickCount(this,336);">components</a>
<a title="Windows Mobile" href="http://www.csdn.net/tag/windowsmobile" target="_blank" onclick="LogClickCount(this,336);">Windows Mobile</a>
<a title="Rails" href="http://www.csdn.net/tag/rails" target="_blank" onclick="LogClickCount(this,336);">Rails</a>
<a title="QEMU" href="http://www.csdn.net/tag/qemu" target="_blank" onclick="LogClickCount(this,336);">QEMU</a>
<a title="KDE" href="http://www.csdn.net/tag/kde" target="_blank" onclick="LogClickCount(this,336);">KDE</a>
<a title="Cassandra" href="http://www.csdn.net/tag/cassandra" target="_blank" onclick="LogClickCount(this,336);">Cassandra</a>
<a title="CloudStack" href="http://www.csdn.net/tag/cloudstack" target="_blank" onclick="LogClickCount(this,336);">CloudStack</a>
<a title="FTC" href="http://www.csdn.net/tag/ftc" target="_blank" onclick="LogClickCount(this,336);">FTC</a>
<a title="coremail" href="http://www.csdn.net/tag/coremail" target="_blank" onclick="LogClickCount(this,336);">coremail</a>
<a title="OPhone " href="http://www.csdn.net/tag/ophone" target="_blank" onclick="LogClickCount(this,336);">OPhone </a>
<a title="CouchBase" href="http://www.csdn.net/tag/couchbase" target="_blank" onclick="LogClickCount(this,336);">CouchBase</a>
<a title="云计算" href="http://www.csdn.net/tag/%E4%BA%91%E8%AE%A1%E7%AE%97" target="_blank" onclick="LogClickCount(this,336);">云计算</a>
<a title="iOS6" href="http://www.csdn.net/tag/iOS6" target="_blank" onclick="LogClickCount(this,336);">iOS6</a>
<a title="Rackspace " href="http://www.csdn.net/tag/rackspace" target="_blank" onclick="LogClickCount(this,336);">Rackspace </a>
<a title="Web App" href="http://www.csdn.net/tag/webapp" target="_blank" onclick="LogClickCount(this,336);">Web App</a>
<a title="SpringSide" href="http://www.csdn.net/tag/springside" target="_blank" onclick="LogClickCount(this,336);">SpringSide</a>
<a title="Maemo" href="http://www.csdn.net/tag/maemo" target="_blank" onclick="LogClickCount(this,336);">Maemo</a>
<a title="Compuware" href="http://www.csdn.net/tag/compuware" target="_blank" onclick="LogClickCount(this,336);">Compuware</a>
<a title="大数据" href="http://www.csdn.net/tag/%E5%A4%A7%E6%95%B0%E6%8D%AE" target="_blank" onclick="LogClickCount(this,336);">大数据</a>
<a title="aptech" href="http://www.csdn.net/tag/aptech" target="_blank" onclick="LogClickCount(this,336);">aptech</a>
<a title="Perl" href="http://www.csdn.net/tag/perl" target="_blank" onclick="LogClickCount(this,336);">Perl</a>
<a title="Tornado" href="http://www.csdn.net/tag/tornado" target="_blank" onclick="LogClickCount(this,336);">Tornado</a>
<a title="Ruby" href="http://www.csdn.net/tag/ruby" target="_blank" onclick="LogClickCount(this,336);">Ruby</a>
<a title="Hibernate" href="http://www.csdn.net/hibernate" target="_blank" onclick="LogClickCount(this,336);">Hibernate</a>
<a title="ThinkPHP" href="http://www.csdn.net/tag/thinkphp" target="_blank" onclick="LogClickCount(this,336);">ThinkPHP</a>
<a title="HBase" href="http://www.csdn.net/tag/hbase" target="_blank" onclick="LogClickCount(this,336);">HBase</a>
<a title="Pure" href="http://www.csdn.net/tag/pure" target="_blank" onclick="LogClickCount(this,336);">Pure</a>
<a title="Solr" href="http://www.csdn.net/tag/solr" target="_blank" onclick="LogClickCount(this,336);">Solr</a>
<a title="Angular" href="http://www.csdn.net/tag/angular" target="_blank" onclick="LogClickCount(this,336);">Angular</a>
<a title="Cloud Foundry" href="http://www.csdn.net/tag/cloudfoundry" target="_blank" onclick="LogClickCount(this,336);">Cloud Foundry</a>
<a title="Redis" href="http://www.csdn.net/tag/redis" target="_blank" onclick="LogClickCount(this,336);">Redis</a>
<a title="Scala" href="http://www.csdn.net/tag/scala" target="_blank" onclick="LogClickCount(this,336);">Scala</a>
<a title="Django" href="http://www.csdn.net/tag/django" target="_blank" onclick="LogClickCount(this,336);">Django</a>
<a title="Bootstrap" href="http://www.csdn.net/tag/bootstrap" target="_blank" onclick="LogClickCount(this,336);">Bootstrap</a>
    </div>

</div>
  <script language="javascript" type="text/javascript">     
      $(function(){
              setTimeout(function(){
                  $.get("/cffishappy/svc/GetTagContent",function(data){
                      $(".tag_list").html(data).show();
                  });     
              });
          },500);                       
 </script> 


<div id="pop_win" style="display:none ;position: absolute; z-index: 10000; border: 1px solid rgb(220, 220, 220); top: 222.5px; left: 630px; opacity: 1; background: none 0px 0px repeat scroll rgb(255, 255, 255);">
    
</div>
<div id="popup_mask"></div>
<style>
    #popup_mask
    {
        position: absolute;
        width: 100%;
        height: 100%;
        background: #000;
        z-index: 9999;
        left: 0px;
        top: 0px;
        opacity: 0.3;
        filter: alpha(opacity=30);
        display: none;
    }

</style>




<script type="text/javascript">
    $(function(){
        setTimeout(function(){
            $(".comment_body:contains('回复')").each(function(index,item){
                var u=$(this).text().split('：')[0].toString().replace("回复","")
                var thisComment=$(this);
                if(u)
                {
                    $.getJSON("https://passport.csdn.net/get/nick?callback=?", {users: u}, function(a) {
                        if(a!=null&&a.data!=null&&a.data.length>0)
                        {
                            nick=a.data[0].n; 
                            if(u!=nick)
                            {
                                thisComment.text(thisComment.text().replace(u,nick));  
                            }
                        }       
                    });  
                }
            });         

        },200);  

        setTimeout(function(){
            $(".math").each(function(index,value){$(this).find("span").last().css("color","#fff"); })
        },5000);

        setTimeout(function(){
            $(".math").each(function(index,value){$(this).find("span").last().css("color","#fff"); })
        },10000);

        setTimeout(function(){
            $(".math").each(function(index,value){$(this).find("span").last().css("color","#fff"); })
        },15000);
        
        setTimeout(function(){
            $("a img[src='http://js.tongji.linezing.com/stats.gif']").parent().css({"position":"absolute","left":"50%"});
        },300);
    });

    function loginbox(){
        var $logpop=$("#pop_win");
        $logpop.html('<iframe src="https://passport.csdn.net/account/loginbox?service=http://static.blog.csdn.net/callback.htm" frameborder="0" height="600" width="400" scrolling="no"></iframe>');

        $('#popup_mask').css({
            opacity: 0.5,
            width: $( document ).width() + 'px',
            height:  $( document ).height() + 'px'
        });
        $('#popup_mask').css("display","block");
 
        $logpop.css( {
            top: ($( window ).height() - $logpop.height())/ 2  + $( window 
       ).scrollTop() + 'px',
            left:($( window ).width() - $logpop.width())/ 2
        } );
 
        setTimeout( function () {
            $logpop.show();
            $logpop.css( {
                opacity: 1
            } );
        }, 200 );
 
        $('#popup_mask').unbind("click");
        $('#popup_mask').bind("click", function(){
            $('#popup_mask').hide();
            var $clopop = $("#pop_win");
            $("#common_ask_div_sc").css("display","none");
            $clopop.css( {
                opacity: 0
            } );
            setTimeout( function () {
                $clopop.hide();
            }, 350 );
            return false;
        });
    }   

</script>
 <script language="javascript" type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/async_new.js.下载"></script>      




                        <div class="clear">
                        </div>
                    </div>                   
                
            </div>
                   
           <div id="side">
               
    <div class="side">
<div id="panel_Profile" class="panel">
<ul class="panel_head"><span>个人资料</span></ul>
<ul class="panel_body profile">
<div id="blog_userface">
    <a href="http://my.csdn.net/cffishappy" target="_blank">
    <img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/1_cffishappy.jpg" title="访问我的空间" style="max-width:90%">
    </a>
    <br>
    <span><a href="http://my.csdn.net/cffishappy" class="user_name" target="_blank">cffishappy</a></span>
</div>
<div class="interact">

    <a href="javascript:void(0);" class="attent" id="span_add_follow" title="[加关注]"></a>

 <a href="javascript:void(0);" class="letter" title="[发私信]" onclick="window.open(&#39;http://msg.csdn.net/letters/model?receiver=cffishappy&#39;,&#39;_blank&#39;,&#39;height=350,width=700&#39;);_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_sixin&#39;])"></a>  
</div>
<div id="blog_medal">
                <div id="bms_box">
                                            <a target="_blank">
                                                    <img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/chizhiyiheng.png" onmouseover="m_over_m(this,4)" onmouseout="m_out_m()" alt="2">
                                            </a>
               </div>
</div>
<ul id="blog_rank">
    <li>访问：<span>392547次</span></li>
    <li>积分：<span>4486</span> </li>    
    <li>等级： <span style="position:relative;display:inline-block;z-index:1">
            <img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/blog5.png" alt="" style="vertical-align: middle;" id="leveImg">
            <div id="smallTittle" style=" position: absolute;  left: -24px;  top: 25px;  text-align: center;  width: 101px;  height: 32px;  background-color: #fff;  line-height: 32px;  border: 2px #DDDDDD solid;  box-shadow: 0px 2px 2px rgba (0,0,0,0.1);  display: none;   z-index: 999;">
            <div style="left: 42%;  top: -8px;  position: absolute;  width: 0;  height: 0;  border-left: 10px solid transparent;  border-right: 10px solid transparent;  border-bottom: 8px solid #EAEAEA;"></div>
            积分：4486 </div>
        </span>  </li>
    <li>排名：<span>第5327名</span></li>
</ul>
<ul id="blog_statistics">
    <li>原创：<span>93篇</span></li>
    <li>转载：<span>99篇</span></li>
    <li>译文：<span>0篇</span></li>
    <li>评论：<span>50条</span></li>
</ul>
</ul>
</div>


<div class="panel" id="panel_Search">
    <ul class="panel_head"><span>文章搜索</span></ul>
    <ul class="panel_body">
        <form id="frmSearch" action="http://so.csdn.net/search" class="form_search" target="_blank">
        <span><input id="inputSearch" type="text" class="blogsearch" title="请输入关键字"></span>
        <input id="btnSubmit" type="button" value="搜索" title="search in blog">
        <input type="hidden" name="q" id="inputQ">
        <input type="hidden" name="t" value="blog">
        <a id="btnSearchBlog" target="_blank"></a>
        </form>
    </ul>
</div>

<script type="text/javascript">
    $(function () {
        $("#btnSubmit").click(function () {           
            search();
        });

        $("#frmSearch").submit(function () {
            search();
            return false;
        });

        function search()
        {
            var url = "http://so.csdn.net/so/search/s.do?q=" + encodeURIComponent($("#inputSearch").val()) + "&u=" + username + "&t=blog";
            window.location.href = url;
        }   
    });
</script><div id="panel_Category" class="panel">
<ul class="panel_head"><span>文章分类</span></ul>
<ul class="panel_body">    
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/884788" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">VC++基础</a><span>(32)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/885141" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">电脑小知识</a><span>(15)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/890299" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">生活小哲理</a><span>(16)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/883975" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">流媒体</a><span>(48)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/903881" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">编程中遇到的函数和变量</a><span>(13)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/904224" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">VC编程中遇到的问题及注意点</a><span>(5)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/919951" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">MFC学习</a><span>(13)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/931333" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">Linux学习</a><span>(12)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/1081242" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">编译错误总结</a><span>(18)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/1082812" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">android 学习</a><span>(2)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/1116502" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">播放器制作</a><span>(1)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/1122603" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">STL学习</a><span>(5)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/1124742" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">PHP学习</a><span>(5)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/1146515" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">天国之路（主给我的恩赐）</a><span>(1)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/1148149" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">html学习</a><span>(1)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/1198423" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">VLC学习文档</a><span>(2)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/1271167" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">嵌入式操作系统</a><span>(1)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/6116669" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">SDL</a><span>(1)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/6170993" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">webrtc</a><span>(10)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/6185337" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">综合基础学习</a><span>(1)</span>
                </li>
                 <li>
                    <a href="http://blog.csdn.net/cffishappy/article/category/6233234" onclick="_gaq.push([&#39;_trackEvent&#39;,&#39;function&#39;, &#39;onclick&#39;, &#39;blog_articles_wenzhangfenlei&#39;]); ">opencv</a><span>(3)</span>
                </li>
</ul>
</div><div id="panel_Archive" class="panel">
<ul class="panel_head"><span>文章存档</span></ul>
<ul class="panel_body">
<div id="archive_list"><li><a href="http://blog.csdn.net/cffishappy/article/month/2016/08">2016年08月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2016/07">2016年07月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2016/06">2016年06月</a><span>(4)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2016/05">2016年05月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2016/04">2016年04月</a><span>(12)</span></li><span class="hidelist" style="display:none;"><li><a href="http://blog.csdn.net/cffishappy/article/month/2016/03">2016年03月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2013/10">2013年10月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2013/01">2013年01月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2012/12">2012年12月</a><span>(4)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2012/11">2012年11月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2012/09">2012年09月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2012/08">2012年08月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2012/07">2012年07月</a><span>(6)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2012/06">2012年06月</a><span>(11)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2012/05">2012年05月</a><span>(21)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2012/04">2012年04月</a><span>(28)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2012/03">2012年03月</a><span>(18)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2012/02">2012年02月</a><span>(10)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2011/12">2011年12月</a><span>(9)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2011/11">2011年11月</a><span>(15)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2011/10">2011年10月</a><span>(25)</span></li><li><a href="http://blog.csdn.net/cffishappy/article/month/2011/09">2011年09月</a><span>(13)</span></li></span><div id="archive_list_button" class="list_closed">展开</div></div>
</ul>
</div>
<div id="hotarticls" class="panel">
<ul class="panel_head">
    <span>       
阅读排行    </span>
</ul>

<ul class="panel_body itemlist">
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7352898" title="ffmpeg教程">ffmpeg教程</a><span>(58449)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7750069" title="犀利语2012">犀利语2012</a><span>(25898)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7474336" title="系统错误 无法启动此程序，因为计算机中丢失MFC42D.DLL。尝试重新安装该程序以解决此问题">系统错误 无法启动此程序，因为计算机中丢失MFC42D.DLL。尝试重新安装该程序以解决此问题</a><span>(11742)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/6930899" title="CProgressCtrl  进度条">CProgressCtrl  进度条</a><span>(11033)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7601228" title="ffmpeg编码示例">ffmpeg编码示例</a><span>(8079)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7283731" title="导入adroid工程出现：unable to get system library for the project">导入adroid工程出现：unable to get system library for the project</a><span>(7595)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7651369" title="error   C2597:   illegal   reference   to   data   member  xxxx   in   a   static member   function">error   C2597:   illegal   reference   to   data   member  xxxx   in   a   static member   function</a><span>(7511)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7434483" title="用C写一个简单病毒">用C写一个简单病毒</a><span>(7269)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7005115" title="signal(SIGCLD,SIG_IGN)">signal(SIGCLD,SIG_IGN)</a><span>(6718)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7402370" title="GetDlgItemText（）的用法">GetDlgItemText（）的用法</a><span>(5852)</span>
</li>
</ul>
</div>
<div id="hotarticls2" class="panel">
<ul class="panel_head"><span>评论排行</span></ul>
<ul class="panel_body itemlist">
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7352898" title="ffmpeg教程">ffmpeg教程</a><span>(9)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7283731" title="导入adroid工程出现：unable to get system library for the project">导入adroid工程出现：unable to get system library for the project</a><span>(7)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7474336" title="系统错误 无法启动此程序，因为计算机中丢失MFC42D.DLL。尝试重新安装该程序以解决此问题">系统错误 无法启动此程序，因为计算机中丢失MFC42D.DLL。尝试重新安装该程序以解决此问题</a><span>(4)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7434483" title="用C写一个简单病毒">用C写一个简单病毒</a><span>(3)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7429834" title="MFC添加控件变量运行不了？">MFC添加控件变量运行不了？</a><span>(3)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7631424" title="avcodec_decode_audio2返回值为-1？">avcodec_decode_audio2返回值为-1？</a><span>(2)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7261632" title="判断H264码流的关键帧">判断H264码流的关键帧</a><span>(2)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7601228" title="ffmpeg编码示例">ffmpeg编码示例</a><span>(2)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7790139" title="BSCMAKE: error BK1506 : cannot open file &#39;.\Debug\Client_DM36xDlg.sbr&#39;: No such file or directory">BSCMAKE: error BK1506 : cannot open file '.\Debug\Client_DM36xDlg.sbr': No such file or directory</a><span>(2)</span>
</li>
<li>
<a href="http://blog.csdn.net/cffishappy/article/details/7565521" title="见证1">见证1</a><span>(2)</span>
</li>
</ul>
</div>
<div id="homepageArticles" class="panel tracking-ad" data-mod="popu_4">
<ul class="panel_head"><span>推荐文章</span></ul>
<ul class="panel_body" id="ad_commend">
<ul>
<li><a href="http://blog.csdn.net/mmoaay/article/details/54562045" target="_blank">* 造轮子 | 如何设计一个面向协议的 iOS 网络请求库</a></li>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/53122387" target="_blank">* Android新特性介绍，ConstraintLayout完全解析</a></li>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/54882693" target="_blank">* Android 热修复 Tinker接入及源码浅析</a></li>
<li><a href="http://blog.csdn.net/zwgdft/article/details/54728677" target="_blank">* 创业公司做数据分析（六）数据仓库的建设</a></li>
<li><a href="http://blog.csdn.net/chenssy/article/details/54883355" target="_blank">* 【死磕Java并发】-----深入分析synchronized的实现原理</a></li>


</ul></ul>
</div>


<div id="newcomments" class="panel">
<ul class="panel_head"><span>最新评论</span></ul>
<ul class="panel_body itemlist">
    <li>
   
         <a href="http://blog.csdn.net/cffishappy/article/details/7651369#comments">error   C2597:   illegal   reference   to   data   member  xxxx   in   a   static member   function</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/kouten1" class="user_name">kouten1</a>:
怎么建立指针呢我觉得好难
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/cffishappy/article/details/51770912#comments">opencv-3.1.0  CMake出现 Downloading opencv_ffmpeg.dll...</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/wang123hainan" class="user_name">wang123hainan</a>:
楼主，更新了还是不行啊·····
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/cffishappy/article/details/50971551#comments">AVPacket  &amp;&amp; av_read_frame 会导致内存泄漏</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/cffishappy" class="user_name">cffishappy</a>:
@phoromeon:是的，用在循环体外可以
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/cffishappy/article/details/50971551#comments">AVPacket  &amp;&amp; av_read_frame 会导致内存泄漏</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/phoromeon" class="user_name">phoromeon</a>:
在函数中局部使用AVPacket是可行的，但切忌用在循环体内
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/cffishappy/article/details/7565521#comments">见证1</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/cffishappy" class="user_name">cffishappy</a>:
@king1989720:是啊
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/cffishappy/article/details/7474336#comments">系统错误 无法启动此程序，因为计算机中丢失MFC42D.DLL。尝试重新安装该程序以解决此问题</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/wxw1145897898" class="user_name">北城飘雪</a>:
重新变异就好了
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/cffishappy/article/details/7283731#comments">导入adroid工程出现：unable to get system library for the project</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/a654612856" class="user_name">a654612856</a>:
谢谢了.
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/cffishappy/article/details/7429834#comments">MFC添加控件变量运行不了？</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/wayxl184" class="user_name">wayxl184</a>:
我的问题解决了
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/cffishappy/article/details/7429834#comments">导入adroid工程出现：unable to get system library for the project</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/sinat_26789919" class="user_name">sinat_26789919</a>:
谢谢。
    </p>
    </li>
    <li>
   
         <a href="http://blog.csdn.net/cffishappy/article/details/7429834#comments">导入adroid工程出现：unable to get system library for the project</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/u012398365" class="user_name">JianYiLead</a>:
在此纠正下博主，不是版本高低的问题，而是版本是否存在。
    </p>
    </li>
</ul>
</div>
    </div>
    <div class="clear">
    </div>


                   <!-- 广告位开始 --> 
                    <div class="J_adv" data-view="true" data-mod="ad_popu_190" data-mtp="37" data-order="40" data-con="ad_content_1260" style="width: 200px; height: 200px;"><!-- 广告占位容器 --><div id="cpro_u2734128"><iframe id="iframeu2734128_0" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/ccom(2).html" width="200" height="200" align="center,center" vspace="0" hspace="0" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" style="border:0; vertical-align:bottom;margin:0;" allowtransparency="true"></iframe></div><!-- 投放代码 --><script type="text/javascript">(window['cproStyleApi'] = window['cproStyleApi'] || {})['u2734128']={at:'3',rsi0:'200',rsi1:'200',pat:'17',tn:'baiduCustNativeAD',rss1:'#FFFFFF',conBW:'1',adp:'1',ptt:'0',titFF:'%E5%BE%AE%E8%BD%AF%E9%9B%85%E9%BB%91',titFS:'',rss2:'#000000',titSU:'0'};/*服务器频道首页置顶Banner960*90，创建于2014-7-3*/(window.cproArray = window.cproArray || []).push({id:'u2734128'});  </script>  <script src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/c.js.下载" type="text/javascript"></script></div> 
                    <!-- 广告位结束 -->

           </div>   

            <div class="clear">
            </div>
        </div>

        

<script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/cnick.js.下载"></script>
<script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/newblog.min.js.下载"></script>


<script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/showblogmedal.ashx"></script>
<script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/JavaScript1.js.下载"></script><link rel="stylesheet" type="text/css" href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/pub_footer_2014.css"><div class="pub_fo"><div id="pub_footerall" class="pub_footer_new"><dl><dt></dt> <dd class="foot_sub_menu"><a href="http://www.csdn.net/company/about.html" target="_blank">公司简介</a><span>|</span><a href="http://www.csdn.net/company/recruit.html" target="_blank">招贤纳士</a><span>|</span><a href="http://www.csdn.net/company/marketing.html" target="_blank">广告服务</a><span>|</span><a href="http://www.csdn.net/company/contact.html" target="_blank">联系方式</a><span>|</span><a href="http://www.csdn.net/company/statement.html" target="_blank">版权声明</a><span>|</span><a href="http://www.csdn.net/company/layer.html" target="_blank">法律顾问</a><span>|</span><a href="mailto:webmaster@csdn.net">问题报告</a><span>|</span><a target="_blank" href="http://www.csdn.net/friendlink.html">合作伙伴</a><span>|</span><a href="http://bbs.csdn.net/forums/Service" target="_blank">论坛反馈</a></dd><dd class="foot_contact"><a href="javascript:void(0);" target="_blank" class="qq">网站客服</a><a href="http://wpa.qq.com/msgrd?v=3&amp;uin=2251809102&amp;site=qq&amp;menu=yes" target="_blank" class="qq">杂志客服</a><a href="http://e.weibo.com/csdnsupport/profile" target="_blank" class="weibo">微博客服</a><a href="mailto:webmaster@csdn.net" class="email" title="联系邮箱">webmaster@csdn.net</a><span class="phone" title="服务热线">400-600-2320</span><span class="interval">|</span><span>北京创新乐知信息技术有限公司 版权所有</span><span class="interval">|</span><span>江苏知之为计算机有限公司</span><span class="interval">|</span><span>江苏乐知网络技术有限公司</span></dd><dd class="foot_copyright"><span>京&nbsp;ICP&nbsp;证&nbsp;09002463&nbsp;号</span><span class="interval">|</span><span>Copyright © 1999-2016, CSDN.NET, All Rights Reserved&nbsp;</span><a href="http://www.hd315.gov.cn/beian/view.asp?bianhao=010202001032100010" target="_blank"><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/gongshang_logos.gif" alt="GongshangLogo" title=""></a></dd></dl></div></div><div id="note1" class="csdn_note" style="display:none; position:absolute; z-index:9999; width:440px">  <span class="notice_top_arrow"><span class="inner"></span></span>  <div class="box"></div></div><div class="csdn_notice_tip" style="position: absolute; z-index: 9990; width: 170px; left: -72px; top: 418px; display: block;">  <iframe src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/saved_resource(2).html" frameborder="0" scrolling="no" style="z-index:-1;position:absolute;top:0;left:0;width:100%;height:100%;background:transparent"></iframe>  <div class="tip_text">您有<strong>124</strong>条新通知</div>  <a href="javascript:void 0" class="close2"></a></div><script id="noticeScript" type="text/javascript" btnid="header_notice_num" wrapid="note1" count="5" subcount="5" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/notify.js.下载"></script>

<script type="text/javascript">document.write("<img src=http://counter.csdn.net/pv.aspx?id=24 border=0 width=0 height=0>");</script><img src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/pv.aspx" border="0" width="0" height="0">
<script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/counter.js.下载"></script><script type="text/javascript" charset="UTF-8" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/msg.popup.js.下载"></script>
<script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/ad-blog.js.下载"></script>
<script type="text/javascript">
    $(function () {
        function __get_code_toolbar(snippet_id) {
            return $("<span class='tracking-ad' data-mod='popu_167'><a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "' target='_blank' title='在CODE上查看代码片'  style='text-indent:0;'><img src='https://code.csdn.net/assets/CODE_ico.png' width=12 height=12 alt='在CODE上查看代码片' style='position:relative;top:1px;left:2px;'/></a></span>"
                    + "<span class='tracking-ad' data-mod='popu_170'><a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "/fork' target='_blank' title='派生到我的代码片' style='text-indent:0;'><img src='https://code.csdn.net/assets/ico_fork.svg' width=12 height=12 alt='派生到我的代码片' style='position:relative;top:2px;left:2px;'/></a></span>");
        }
        
        $("[code_snippet_id]").each(function () {
            __s_id = $(this).attr("code_snippet_id");
            if (__s_id != null && __s_id != "" && __s_id != 0 && parseInt(__s_id) > 70020) {
                __code_tool = __get_code_toolbar(__s_id);
                $(this).prev().find(".tools").append(__code_tool);
            }
        });

        $(".bar").show();
    });
</script>





    </div><input type="hidden" id="aa_g_data_ids">
      <!--new top-->
    
    <script id="csdn-toolbar-id" btnid="header_notice_num" wrapid="note1" count="5" subcount="5" type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/toolbar.js.下载"></script>
     <!--new top-->
   
    <link href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/ask_float_block.css" type="text/css" rel="stylesheet">
    <script language="JavaScript" type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/wmd.js.下载"></script>
    <script language="JavaScript" type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/showdown.js.下载"></script>
    <script language="JavaScript" type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/prettify.js.下载"></script>
    <script language="JavaScript" type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/ask_float_block.js.下载"></script>
   

   

  <div id="a52b5334d" style="width: 1px; height: 1px; display: none;">
                    <script id="adJs52b5334" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/52b5334.js.下载"></script>
                    <script>document.getElementById("adJs52b5334").src = "http://ads.csdn.net/js/opt/52b5334.js?t=" + Math.random();</script>
   </div>

    <link rel="stylesheet" href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/blog_code.css">
    <script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/saveToCode.js.下载"></script>
      <script type="text/javascript" src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/main.js(1).下载"></script>

     <link rel="stylesheet" href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/fa.css">

    <div class="pop_CA_cover" style="display:none"></div>
    <div class="pop pop_CA" style="display:none">
          <div class="CA_header">
            收藏助手
            <span class="cancel_icon" id="fapancle" onclick="$(&#39;.pop_CA&#39;).hide();$(&#39;.pop_CA_cover&#39;).hide();"></span>
          </div>
          <iframe src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/saved_resource(3).html" id="fa" frameborder="0" width="100%" height="360" scrolling="no">
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;   
 </iframe></div><div id="tag-suggest-pop">
  <div class="relative">
    <div class="close"></div>
    <div class="content"></div>
  </div>
</div><link rel="stylesheet" type="text/css" media="screen" href="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/ask_float_fonts_css-6b30a53970eb5c3a2a045e3df585b475.css"><div data-mod="popu_64" class="csdn-tracking-statistics" chg-blk="0"><a id="com-quick-reply" title="快速回复" style="top:420px"></a><a id="com-quick-collect" title="我要收藏" style="top:458px"></a><a id="com-d-top-a" style="top: 496px; display: none;" title="返回顶部" onclick=""></a> </div><div class="pop_edit ask_second comm_ask_second"><h3>提问</h3><span class="ask_float_span">您的问题将会被发布在“<a class="ask_float_channel" href="http://ask.csdn.net/" target="_blank" style="cursor:pointer">技术问答</a>”频道</span><a href="http://blog.csdn.net/cffishappy/article/details/7352898#" nodetype="close" class="close">×</a><div class="context"><div class="err_div"><span class="err_ico"></span><span class="err_txt">该问题已存在，请勿重复提问</span></div><div class="input_div"><input id="askInputSecond" type="text" style="font-size:14px;" placeholder="问题标题"></div><div class="cm_box"><div class="cm_dialog"></div> <div class="pop_cm cm_add_link"><input type="text" placeholder="链接内容" id="af_cm_link_txt"><input type="text" placeholder="链接地址" id="af_cm_link_url"><input type="text" placeholder="链接提示" id="af_cm_link_tit"><div class="text-right"><span class="btn btn-default btn-sm" id="add_link_btn">插入链接</span> </div> </div><div class="pop_cm cm_add_img"><div class="nav-tabs"><a class="img_tab active" href="http://blog.csdn.net/cffishappy/article/details/7352898#tab_upload">本地上传</a><a class="img_tab" href="http://blog.csdn.net/cffishappy/article/details/7352898#tab_weburl">网络图片</a></div><div class="tab_panel active" id="tab_upload"><div class="set_img"><iframe src="./ffmpeg教程 - cffishappy的专栏 - 博客频道 - CSDN.NET_files/upload.html"></iframe></div></div><div class="tab_panel" id="tab_weburl"><input type="text" placeholder="图片地址" id="af_cm_img_url"><input type="text" placeholder="图片说明" id="af_cm_img_alt"><div class="text-right"><span class="btn btn-default btn-sm" id="add_img_btn">插入图片</span> </div></div> </div></div> <textarea id="editor_all" rows="8" style="display: none;"></textarea><div class="editor-toolbar"><i class="separator">|</i><a class="icon-headline" title="标题一（Ctrl+Alt+1）"></a><a class="icon-heading" title="标题二（Ctrl+Alt+2）"></a><a class="icon-bold" title="粗体（Ctrl+B）"></a><a class="icon-italic" title="斜体（Ctrl+I）"></a><i class="separator">|</i><a class="icon-quote-left" title="引用（Ctrl+’）"></a><a class="icon-code" title="插入代码片（Ctrl+,）"></a><a class="icon-list-ul" title="无序列表（Ctrl+L）"></a><a class="icon-list-ol" title="有序列表（Ctrl+Alt+L）"></a><i class="separator">|</i><a class="icon-link" title="添加链接（Ctrl+K）"></a><a class="icon-picture" title="添加图片（Ctrl+Alt+I）"></a><i class="separator">|</i><a class="icon-reply" title="撤退（Ctrl+Z）"></a><a class="icon-share-alt" title="前进（Ctrl+Shift+Z）"></a><i class="separator">|</i><a class="icon-info" href="http://ask.csdn.net/pages/markdown" target="_blank" title="markdown语法参考"></a><a class="icon-preview" title="预览"></a><i class="separator">|</i></div><div class="CodeMirror cm-s-paper CodeMirror-focused"><div style="overflow: hidden; position: relative; width: 3px; height: 0px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" style="position: absolute; padding: 0px; width: 1000px; height: 1em; outline: none; font-size: 4px;" tabindex="0"></textarea></div><div class="CodeMirror-hscrollbar"><div style="height: 1px;"></div></div><div class="CodeMirror-vscrollbar"><div style="width: 1px;"></div></div><div class="CodeMirror-scrollbar-filler"></div><div class="CodeMirror-gutter-filler"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="min-width: 33px;"><div style="position: relative;"><div class="CodeMirror-lines"><div style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre>&nbsp;<span style="display: inline-block; width: 1px; margin-right: -1px;">&nbsp;</span></pre></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code"></div><div class="CodeMirror-cursor">&nbsp;</div><div class="CodeMirror-cursor CodeMirror-secondarycursor">&nbsp;</div></div></div></div></div><div style="position: absolute; height: 30px; width: 1px;"></div><div class="CodeMirror-gutters" style="display: none;"></div></div></div><div class="editor-statusbar"><span class="lines">0</span><span class="words">0</span><span class="cursor">0:0</span></div><div class="div_tags clearfix"><div id="divSearchTags" class="tags_con"><input type="text"></div><input type="hidden" name="txtSearchTags"></div><div id="ask2_tagRecomm_div" class="drt_tagRecomm tracking-ad" data-mod="popu_73"><span class="drt_tit">推荐标签：</span></div></div><div class="success"><div class="left_area"><input id="chk_cb" type="checkbox"><span class="wyxs">我要悬赏</span><input id="cb_num" class="cb_num" readonly="true"><span class="phib_rii"><span> 币</span></span></div><a href="http://blog.csdn.net/cffishappy/article/details/7352898#" nodetype="cancel" class="cancel">取消</a><a href="http://blog.csdn.net/cffishappy/article/details/7352898#" nodetype="ok" class="ok">发布</a></div></div><div id="common_ask_div_sc" class="searchContainer"><div class="sTitle">可能存在类似的问题：</div><div class="sFooter"><a class="sFirstNewAsk">我想提一个新问题</a></div></div><div id="mask_code"></div><div class="gist_edit"><div class="save_snippets clearfix"><div class="tit"><h3>保存代码片</h3><span>整理和分享保存的代码片，请访问<a href="https://code.csdn.net/snippets_manage" target="_blank">代码笔记</a></span></div><div class="con_form"><ul class="gist_edit_list clearfix"><li><span class="red">*</span><span class="txt">标题</span><input id="form_title" class="form-input" placeholder="ffmpeg教程" type="text"></li><li><span class="red">*</span><span class="txt">描述</span><textarea id="form-textarea" class="form-textarea" placeholder="ffmpeg教程： http://blog.csdn.net/cffishappy/article/details/7352898"></textarea></li><li><span class="red">&nbsp;</span><span class="txt">标签</span><div id="divSearchTags"><span class="label blog_tag"><span>audio</span><a title="Removing tag" href="javascript:;">x</a></span><span class="label blog_tag"><span>video</span><a title="Removing tag" href="javascript:;">x</a></span><span class="label blog_tag"><span>delay</span><a title="Removing tag" href="javascript:;">x</a></span><span class="label blog_tag"><span>stream</span><a title="Removing tag" href="javascript:;">x</a></span><span class="label blog_tag"><span>buffer</span><a title="Removing tag" href="javascript:;">x</a></span><span class="label blog_tag"><span>codec</span><a title="Removing tag" href="javascript:;">x</a></span><input id="insertTag" class="insertTag" placeholder="请输入标签，按Enter生成(最多5项)" type="text" value="" name="insertTag" maxlength="21" style="color: rgb(51, 51, 51);"><input id="OrganTag" class="OrganTag" type="hidden" name="OrganTag" value="audio,video,delay,stream,buffer,codec,"><input id="OldOrganTag" class="OldOrganTag" type="hidden" name="OldOrganTag" value=""><input type="hidden" name="txtSearchTags"></div></li></ul></div><div class="bottom-bar"><a href="javascript:;" class="btn-submit btn-cancel">取消</a><span class="tracking-ad" data-mod="popu_250"><a class="btn-submit btn-confirm" href="javascript:;" target="_blank">确定</a></span></div></div></div></body></html>